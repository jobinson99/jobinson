<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>黑传说</title>
    <description>乌抵天明</description>
    <link>http://jobinson.ga/</link>
    <atom:link href="http://jobinson.ga/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>张尧学透明计算理解</title>
        <description>&lt;p&gt;长文可能很多人看不下去，先说结论：张所提出并实现的透明计算，确实是世界独创的，至今仍然如此，获奖实至名归。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;有关透明计算的信息&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;自然科学一等奖得主中南大学校长张尧学简历&lt;/h3&gt;

&lt;p&gt;1956年1月生，湖南常德澧县人，1982年本科毕业于陕西西北电讯工程学院(现陕西西安电子科技大学)，1987年4月加入中国共产党，获日本东北大学博士学位。教授，博士生导师，中南大学校长，中国工程院院士，中国作家协会会员，国务院学位委员会委员，国务院信息化咨询委员会委员，计算机学会普适计算专委会委员，&lt;strong&gt;解放军总装备部军用计算机及软件技术专业组专家&lt;/strong&gt;，《International Journal of Wireless and Mobile Computing》《Journal of Autonomic and Trusted Computing》《Chinese Journal of Electronics》等国内外学术期刊的编委。曾任教育部高等教育司司长、学位管理与研究生司司长、国务院学位委员会办公室主任、985工程办公室主任、211工程建设办公室主任等学术和行政职务。著有《又见木兰》、《水随天去》等管理类散文集。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1976年10月至1978年10月，在湖南澧县余家台水电站工作，测绘员;&lt;/li&gt;
  &lt;li&gt;1978年10月至1982年07月，在陕西西安电子科技大学(原陕西西北电讯工程学院)电子工程系学习，获学士学位;&lt;/li&gt;
  &lt;li&gt;1982年07月至1983年02月，在西安电子科技大学出国研究生预备班学习;&lt;/li&gt;
  &lt;li&gt;1983年02月至1983年09月，在大连外国语学院日语培训班学习;&lt;/li&gt;
  &lt;li&gt;1983年09月至1990年03月，在日本东北大学硕士生、博士生并获硕士、博士学位;&lt;/li&gt;
  &lt;li&gt;1990年03月至1995年07月，在清华大学计算机系任教师、副教授、教授，教研组副主任;1994年6月任清华大学计算机系副系主任;1995年2月评定为博士研究生导师;&lt;/li&gt;
  &lt;li&gt;1995年07月至1995年10月，在美国麻省理工学院作访问教授;&lt;/li&gt;
  &lt;li&gt;1995年10月至1997年11月，电子部计算机司副司长兼全国电子信息系统推广办公室副主任(挂职);&lt;/li&gt;
  &lt;li&gt;1997年11月至1999年06月，清华大学计算机系教授、博士生导师;&lt;/li&gt;
  &lt;li&gt;1999年06月至2000年06月，教育部科学技术司副司长(主持工作);&lt;/li&gt;
  &lt;li&gt;2000年06月至2001年05月，教育部科学技术司司长;&lt;/li&gt;
  &lt;li&gt;2001年05月至2009年06月，教育部高等教育司司长(其中，2001年11月至2006年5月兼任中央广播电视大学校长;2004年3月至2005年1月参加中央党校一年制中青年干部培训班;2007年5月至2008年9月任北京奥组委挂职总体策划部副部长;2007年当选为中国工程院院士);&lt;/li&gt;
  &lt;li&gt;2009年06月至2011年10月，国务院学位委员会办公室主任、教育部学位管理与研究生教育司司长;&lt;/li&gt;
  &lt;li&gt;2011年11月至今，中南大学校长(副部长级)。&lt;/li&gt;
  &lt;li&gt;2011年10月21日，中共中南大学委员会委员、常委。&lt;/li&gt;
  &lt;li&gt;2011年11月1日，中南大学校长。&lt;/li&gt;
  &lt;li&gt;2015年1月9日，清华大学教授、中南大学校长张尧学院士率队完成的“网络计算的模式及基础理论研究”项目荣获2014年度国家自然科学奖一等奖。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;成就：&lt;/p&gt;

&lt;p&gt;1995年主持研制成功国内首台 &lt;strong&gt;网络路由器&lt;/strong&gt;，并推动了这一事关国家安全和信息产业核心产品的产业化。率先在国际上开展主动服务和透明计算领域的研究，提出了在&lt;strong&gt;时空上扩展&lt;/strong&gt;冯诺依曼结构、把信息存储、运算和管理分开的透明计算理论与方法，并研究成功了基于该理论的 &lt;strong&gt;内核分布式操作系统&lt;/strong&gt; 和&lt;strong&gt;无操作系统的透明计算终端&lt;/strong&gt;，广泛用于中国军事、商务、教育和管理等领域，受到了国内外学术界的重视，被国外同行认为是“先于云计算，并包含了云计算”的原创性学术成果，并正向服务手机、云手机等移动互联网、家庭网等领域扩展。&lt;/p&gt;

&lt;p&gt;在网络基础理论方面提出了被美国同行称为“Zhang’s method”的交互式协议综合法，推动了网络基础理论的发展和进步。以第一获奖人获国家技术发明二等奖一项、国家科技进步二等奖两项；获IEEE AINA07最佳论文奖，何梁何利科技进步奖，美国IET教育基金会教育领先奖，以及亚洲开放大学联合会功勋服务奖等奖项。撰写中英文专著和教材8部，其中《计算机操作系统教程》已销售100余万册，成为国内计算机领域的主要教材之一。&lt;/p&gt;

&lt;p&gt;主持完成了多项国家级科研、国际合作及重大产业化项目。以第一完成人获国家技术发明二等奖1项、国家科技进步二等奖2项、省部级奖励5项。&lt;/p&gt;

&lt;p&gt;主要的研究方向是透明计算和主动服务。透明计算主要是研究如何解决用户通过网络上的同一终端平台使用不同操作系统和相关应用，以及在不同终端平台上使用同一操作系统和相关应用。主动服务是按照用户需求，通过计算机对现有服务进行演化，从而提供尽可能满足用户需求的网络服务的一种计算方法。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;清华大学的通稿&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://news.tsinghua.edu.cn/publish/news/4205/2015/20150112091258538502525/20150112091258538502525_.html&quot;&gt;透明计算引领“下一个计算时代”&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;——“网络计算的模式及基础理论研究”获国家自然科学一等奖&lt;/p&gt;

&lt;p&gt;该研究项目是在张尧学院士带领下，由清华大学计算机系教师周悦芝、林闯、任丰原和中南大学教师王国军共同完成的。该研究在国际上率先提出透明计算的新概念，突破了冯•诺依曼结构的局限，成功研制出了具有独立知识产权的超级操作系统和一系列具有原创性与系统性的重大创新成果，对促进我国计算机及相关产业转型升级发展具有重要意义。&lt;/p&gt;

&lt;p&gt;张尧学院士带领的科研团队自1991年开始，历经20余年的潜心研究，将计算机体系结构与计算模式的创新同国家经济社会的重大需求结合，在国际上首次提出了把一个自治网络虚拟成单机的新计算模式——透明计算。该计算模式把单机总线扩展到网络带宽，从而实现一个自治域内所有计算机的存储器和CPU的统一虚拟管理，以实现在自治域网络环境下的计算、存储和管理分离，并创造性地提出了“流式计算”方法，把操作系统和应用程序转变为能让用户随时随地获取的服务，由服务器统一管理与维护，如同水、电等资源一样，在用户需要时源源不断地提供，用户使用完毕后自动流走，从而始终保持用户终端的小巧轻便和操作简易，同时可以获得大规模数据服务。&lt;/p&gt;

&lt;p&gt;研究团队还根据透明计算原理，成功研制出了具有独立知识产权的，运行在各种操作系统之下、主板之上的超级操作系统（Meta OS），使用户可以根据需要，通过近乎裸机的小终端设备获取不同操作系统平台的各类服务，从而大大降低了对用户终端的要求，解决了各种操作系统安全漏洞及多操作系统的兼容与跨平台问题。该团队还提出了高可靠网络协议和开发方法，研制了多操作系统远程加载协议（MRBP）和网络服务访问协议（NSAP），保证可靠的跨平台操作，将网络互连平台由较高的网络层下降到计算机芯片和操作系统间的接口层，从而打开了被国外厂商控制的芯片与操作系统之间的“黑匣子”，并可以通过在接口层设计保护程序，防止上层软件系统受到攻击和安全漏洞威胁，解决信息网络的安全问题。&lt;/p&gt;

&lt;p&gt;透明计算这一成果在国际上开辟了一个新的研究领域和发展方向，为网络计算提供了全新的模式和理论基础，得到了学术界的高度评价，认为“透明计算取代已经控制了计算机系统思想和实践至少60年之久的传统冯•诺依曼结构”。Intel公司总裁Renee James也认为：“透明计算提供无缝的、跨平台的用户体验，代表了下一个计算时代。”国内外有40多所大学和科研机构正进行相关跟踪研究，200多家国际主要技术媒体对此进行了长篇报道和评论，不少评论认为“这将是首个由中国推动的计算技术”。&lt;/p&gt;

&lt;p&gt;目前，该项目已研制成功多种产品，应用于国防、教育、互联网等领域，未来将进一步推动透明计算与大数据、移动互联网相结合，对国家社会经济发展和网络信息安全提供支撑，推动相关产业升级换代，形成新的学科领域和研究方向。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;申请获奖用的论文&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Yaoxue Zhang and Yuezhi Zhou. Transparent Computing: A New Paradigm for Pervasive Computing, LNCS 4159, 2006 年第1 卷1-11 页.&lt;/li&gt;
  &lt;li&gt;Yaoxue Zhang and Yuezhi Zhou. 4VP+: A Novel Meta OS Approach for Streaming Programs in Ubiquitous Computing, in Proc. of the IEEE 21st International Conference on Advanced Information Networking and Applications (AINA 2007), 2007 年第1 卷394-403 页.&lt;/li&gt;
  &lt;li&gt;Yaoxue Zhang, K. Takahashi, N. Shiratori, and S. Noguchi. An Interactive Protocol Synthesis Algorithm Using a Global State Transition Graph, IEEE Transactions on Software Engineering, 1988 年14(3)卷 394-404 页.&lt;/li&gt;
  &lt;li&gt;Yaoxue Zhang, Hua Chen. A knowledge-based dynamic job-scheduling in low-volume/high-variety manufacturing, Artificial Intelligence in Engineering (UK), 1999 年13(3)卷 241-250 页.&lt;/li&gt;
  &lt;li&gt;林 闯 . 计算机网络和计算机系统的性能评价, 清华大学出版社， ISBN:7-302-04267-5, 2001 年卷109-129 页.&lt;/li&gt;
  &lt;li&gt;Fengyuan Ren, Chuang Lin, Xunhe Yin. Design a congestion controller based on sliding mode variable structure control, Computer Communications, 2005 年28(9)卷 1050-1061 页.&lt;/li&gt;
  &lt;li&gt;Fengyuan Ren, Chuang Lin, Bo Wei. A robust active queue management algorithm in large delay networks, Computer Communications, 2005 年 28(5)卷 485-493 页.&lt;/li&gt;
  &lt;li&gt;Jianer Chen, Guojun Wang, and Songqiao Chen. Locally subcube-connected hypercube networks: theoretical analysis and experimental results, IEEE Transactions on Computers, 2002 年51(5)卷 530-540 页.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-4&quot;&gt;中途退出成员提供的信息&lt;/h3&gt;

&lt;p&gt;作为前透明计算实验室的一员，来谈谈自己的想法好了。&lt;/p&gt;

&lt;p&gt;首先张的透明计算在我校是分为几个项目来做的，每个项目有一个小团队。包括PC、Android手机，平板的透明计算OS，还有基于这个“理念”的移动医疗等应用项目。&lt;/p&gt;

&lt;p&gt;这里面PC端的OS就是我所在的小团队弄出来的。&lt;/p&gt;

&lt;p&gt;其它项目团队怎么弄的我不清楚，PC端基本都是我设计的，实现方案改过几次：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;最初和Intel一起改PXE（这玩意网吧无盘就用它），想多台机器共用一个镜像，但更改的数据分别保存，搞了半天发现PXE跨不了局域网，也用不了无线，不能达到张提出的要求，被推翻了。&lt;/li&gt;
  &lt;li&gt;然后找了个开源的iPXE，号称支持广域网和无线，自定义脚本等诸多功能，整了半天把原型整出来了，又发现丫对无线的支持烂成渣，只支持一两个 802.11g的芯片组，尝试自行写无线驱动，还是不可行，因为要支持的无线网卡太多，只要有机器的网卡驱动没有，那这台机器就无法使用无线来加载透明计算系统，所以又被推翻。&lt;/li&gt;
  &lt;li&gt;截止至我离开前的方案，整了个开源的虚拟机（vbox），虚拟机上运行透明计算系统，存储的操作系统放在服务器，用iSCSI传输，运行的真正操作系统（Windows那些）上装了些自己写的程序做管理和监控。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基本结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;真实操作系统（Windows、Linux）
————————————————-
虚拟机
————————————————
透明计算管理程序
————————————————
Linux
———————————————–
机器硬件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我走之前，所在团队的工作基本上就是在定制Linux和改虚拟机。。。还为这套东西增强些功能。。&lt;/p&gt;

&lt;p&gt;对于这整套东西，我的心里话其实是：没法用。真正使用的操作系统运行在一个虚拟机上，能快到哪去？更别说镜像还是放在服务器上用iSCSI协议来传 输的。央视的新闻我看了，播到展示透明计算机器运行着XP系统的时候，我都笑傻了，为啥？Win7及更新的操作系统可是可以用，但基本慢成狗！如果再在那 上面看个视频，能有10帧就谢天谢地了！首次启动Win7至少需要5分钟以上，如果你还处于10M以下的小水管的话，呵呵呵呵。。。最好别等了。&lt;/p&gt;

&lt;p&gt;虽然团队其他人一直还在优化，但说实话效果很有限，而且这个东西我们自己都认为实在没有什么技术含量，离实用更差得远，这次听说获奖，其它团队怎么样我不清楚，但至少我们做的这个东西确实是没任何资格的。&lt;/p&gt;

&lt;p&gt;还在团队的时候，老师给派新同学进来，要跟他们解释这个东西是什么，我们的回答就是“你理解成用虚拟机搭了个网吧无盘环境就好了”。。。&lt;/p&gt;

&lt;p&gt;上面说的这些仅限我所在团队的工作内容，透明计算还有其他团队，包括其他高富帅学校也有团队在搞，他们的工作我不清楚，肯定比我们做的要高大上得多吧。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;张尧学自己的访谈&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://v.qq.com/page/h/v/q/h0145ebh1vq.html&quot;&gt;原型视频地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其获奖项目“网络计算的模式及基础理论研究”被通俗称为“透明计算”。据报道，这项研究主要在三个方面取得突破：研制了超级操作系统(Meta OS)、实现了计算与存储分离、实现了软硬件分离。&lt;/p&gt;

&lt;p&gt;计算与存储分离很早就能实现了，网吧就是这么干的；这个概念不就是甲骨文等公司20年前提出的NC(网络计算机)吗？“透明计算”的概念乍听起来与云计算似乎无异，它到底有哪些独特之处呢？冯·诺依曼结构被颠覆了吗？Intel的透明计算和张尧学的透明计算是一回事吗？一个长期担任行政职务的人怎么会有时间做科研？张尧学近日接受科技日报独家专访&lt;/p&gt;

&lt;p&gt;“透明计算”与“云计算”&lt;/p&gt;

&lt;p&gt;第一，云计算是由厂商通过服务器端的架构提供计算资源的服务，用户终端
仅仅作为服务的接收端而存在，而透明计算主要关注用户端。用户需要服务时，就从服务器端将需要的软件或数据通过块或页的方式碎片化调用并主要在终端完成计算，而且终端可以装或不装任何数据、软件包括操作系统；第二，云计算主要解决数据的海量存放和使用问题，对软件的云化、特别是操作系统的云化没有提出好的解决方案，而透明计算则较好地解决了这个问题；第三，透明计算还包括了云计算不具备的全过程管理、带宽与缓冲管理等功能；第四，由于云计算的重点不在终端的使用情况上，因而其在终端安全性上没有突破，而透明计算在终端安全性上有很好的考虑。&lt;/p&gt;

&lt;p&gt;“透明计算的实现可以在多个层面，例如在硬件层之上、在中间件层或在应用层。”在张尧学看来，透明计算概念的提出应该早于云计算。&lt;/p&gt;

&lt;p&gt;“云计算大概是从2008年左右被国内熟知，而我们最早做‘透明计算’相关研究是1998年，但当时我们没有称它为这个名字，这个名字是2003年左右微软亚洲研究院的一位领导在参观我的实验室时给起的。”他说。&lt;/p&gt;

&lt;p&gt;发端于索普卡的“透明计算”&lt;/p&gt;

&lt;p&gt;“1998年，一台电脑的售价上万元，升级换代太快，而且病毒很多，我的想法是能不能让电脑变得更简单、更便宜、更安全和跨平台。”张尧学说，他在开发网络计算机的基础上，尝试把操作系统从原本已十分精简的终端上去掉，提出了没有操作系统的计算模式，并着手开发终端系统。&lt;/p&gt;

&lt;p&gt;网络计算机的概念20年前就已提出。张尧学说，但甲骨文等公司的网络计算机用的并不好。“Sun公司还给我们送过一套Sunray系统，一台服务器加40个终端，价格要100万多元人民币，我记得每个终端要1000多美元。虽然是赠送，但不好用，当时也只能用一个操作系统。我就考虑能不能用一种更好的方式，管理网络资源，使得计算机终端更好用、更安全，而且能兼容不同操作系统。”&lt;/p&gt;

&lt;p&gt;张尧学说，最初的研究从无盘站开始，但逐渐发现无盘站有很多局限，如只能识别一个操作系统，速度慢，执行上受用户数、对病毒防护差等的限制。“不过无盘站提供了PXE(预启动执行环境)协议，我们就在这个基础上做扩展。”&lt;/p&gt;

&lt;p&gt;几年后，张尧学的团队做出索普卡电脑。据称，这套系统相当于用一台当时的家用PC，可以带动30个终端，而且可以上多个操作系统。 “索普卡电脑的‘瘦’体现在：它本身是台裸机，没有任何软件，计算机运行所需的操作系统软件和应用软件都能从服务器下载得到。” 一篇题为《索普卡：中国PC “瘦身”之道》的报道这样写道。&lt;/p&gt;

&lt;p&gt;张尧学说，索普卡有两项专利，还转让给了联想等公司。索普卡当时在贵州、云南等偏僻地区及部分边境部队和企业应用情况良好，2003年获得教育部科技进步一等奖以及2004年度的国家技术发明奖二等奖。&lt;/p&gt;

&lt;p&gt;“但是我觉得大学里的科研人员的主要任务应该还是从理论和研究上取得突破，而不是做产品。做产业需要融资、销售和生产等专业团队，这不是我的强项，何况我还在教育部任职。所以我就开始想把索普卡往移动网络、广域网方向推，从理论上思考怎样才能在网络环境下使计算机的使用更加安全和简单。”张尧学说，他从2004年开始这方面的理论研究。&lt;/p&gt;

&lt;p&gt;张尧学于1999年至2011年任职教育部，但他告诉记者：“我在调到教育部之前已和时任教育的主管领导谈好，要继续在清华大学做科研。这位领导和清华大学都是同意的。因此，我出差很少，而且晚上和休息日基本都在实验室，这一点，我想清华大学的同事们都可以证明。”&lt;/p&gt;

&lt;p&gt;与英特尔的合作&lt;/p&gt;

&lt;p&gt;张尧学认为自己长期教授操作系统课程，以及从事协议的研究，对底层协议很熟悉。“操作系统两个最核心的内容是中断和调度，而这两个机制都是只针对单机，我就想能不能在底层硬件之上有个中间层，将操作系统和应用在内的软件从网络上加载到这个中间层上运行，并实现不同软件（包括操作系统及应用）的按需选择和按需调度，从而让不同的硬件和不同的软件系统连接。但这是一个黑匣子，需要反汇编。当时学生们做得很辛苦，后来好歹做成了，但效果不是太理想。这一是由于带宽，二是每个操作系统都要对底层反汇编，很难。”张尧学说。&lt;/p&gt;

&lt;p&gt;与英特尔的合作为该技术的更广泛应用起了很大作用。英特尔致力推广新一代BIOS及其接口标准，即EFI（可扩展固件接口），目前90%的新生产个人电脑已经采用了 EFI及其后的UEFI（统一可扩展固件接口）技术。“用EFI技术来实现透明计算，既支持多操作系统的选择和执行，又很大程度缓解了原来难以在不同硬件平台上运行问题。”&lt;/p&gt;

&lt;p&gt;谈到与英特尔的合作，张尧学说，英特尔在2005年参观了他的实验室并初步接触后，双方于2007年2月签署合作协议后长期合作“至今，我们共签有3个合作协议，Intel公司完全承认我们的知识产权。由于商业协议的条款，我不能透露太多的合作细节。但INTEL美国总部软件与服务部平台技术中心总经理MichaelA.Greene在2013年4月英特尔信息峰会期间有个主题演讲‘透明计算时代’，其中第7、第8、第9页是关于我们合作的描述。这篇讲演的PPT，就挂在&lt;a href=&quot;http://media.cs.tsinghua.edu.cn/~zyx/&quot;&gt;我的清华大学主页下&lt;/a&gt;。”&lt;/p&gt;

&lt;p&gt;“我们的目标是将底层软件做成通用软件、扩展EFI，成为国际标准。而中层和高层的透明计算实现则正在进一步研究。我认为，HTML5是实现透明计算的一种技术手段。可能理解的不对，供大家批评。”张尧学说，“至于Intel的透明计算与我提出的透明计算有什么关系？建议大家采访Intel。我在这方面有充足的证据回答大家的质疑。”&lt;/p&gt;

&lt;p&gt;他表示，目前英特尔已经在台式机、笔记本、上网本、移动互联网设备、平板电脑和智能手机等多个平台上实现了透明计算，包括上海交通大学在内的单位都已使用了英特尔的台式机透明计算系统。而不少大学则购买了由清华专利转让的台式机系统。“清华大学、中南大学和清华的毕业生还基于透明计算思想，研制成功了用手机远程使用多种操作系统和应用的手机透明计算系统等新的系统原型。这次基本上都已公开，我们的知识产权有可能会受到损失。”&lt;/p&gt;

&lt;p&gt;与网络计算机等技术的区别&lt;/p&gt;

&lt;p&gt;总结与网络计算机、远程+VPN+PNS 等技术的区别，张尧学说，“透明计算”的最大突破是提出并部分实现了使终端如何变小以及无缝连接（跨硬件和软件平台）的思想和方法。按照此方法，研制了一个分布式超级操作系统MetaOS。它不仅包括远程启动协议MRBP（I, II）、网络服务访问协议NSAP，还包括可以管理调度不同的操作系统和网络带宽等资源的I/O man以及一个轻量化的网络协议栈等，并可沿使用路径监控网络上的使用情况。他透露，最近某央企控股公司也在国家重大专项支持下基于他们的原理和早期版本研制成功了MetaOS的新版本，并有重大应用。&lt;/p&gt;

&lt;p&gt;一个理想的MetaOS能跟踪和记录来自于不同用户的访问、解决从端系统到服务器之间的各点资源的监控和管理，例如沿途的带宽、缓存等。“以前的计算机是由操作系统来调度各种软件的，但如何以碎片方式调动不同的操作系统，我没听说别人做过。”张尧学说。&lt;/p&gt;

&lt;p&gt;产业化前景可期&lt;/p&gt;

&lt;p&gt;“很多人说我们提出的计算与存储分离早就有了，我也做了十几年了，而且我们有专利。”张尧学说，“而且我们的技术可以让用户根据需要调用资源，指令是碎片化进入终端的，不是操作系统和应用程序全部，这样可以极大简化终端，带宽并不是主要问题”。&lt;/p&gt;

&lt;p&gt;他解释道，简单说来，MetaOS分为客户端和后端软件两部分。如果用户指定某台电脑为储存数据的后端，就安装后端软件，而他要用到的其他电脑、手机及可穿戴设备则需安装一个客户端软件。如此一来，他打开任何一个终端都能随意调用后端的程序和数据。清华和中南大学的透明计算研究团队则做出了更多的新产品原型，包括定制应用和不同操作系统的透明手机。&lt;/p&gt;

&lt;p&gt;他介绍道，致力于将透明计算技术产业化的工作开展，在可穿戴设备、智慧家庭、医疗和教育大数据等方面都会有巨大的应用前景。例如，今后出国不用带笔记本电脑，远在非洲就可以存取和操作在北京计算机中的资源；医生在手机上可以使用专业软件调出并分析如核磁共振影像等各种医疗数据， 等等。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;解剖张和透明计算&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Those who can, Do; and those who cann’t, Teach; and those who cann’t anything, Suck!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-7&quot;&gt;“透明计算”服务端的结构&lt;/h3&gt;

&lt;p&gt;先看看 普通电脑，云计算，chromeos，pxe 和 “透明计算” 的软硬件结构区别！&lt;/p&gt;

&lt;p&gt;一般一台计算机的软件从硬件层到外应用软件层的结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;资源供应方=用户方
核芯+主板——》基本硬件管理层（比如bois uefi）——》硬件利用层（比如linux核心）
——》基本图形系统（比如x）
——》用户界面系统（比如kde gnome）——》网络服务（远程桌面之类）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;资源和用户端分离：&lt;/p&gt;

&lt;p&gt;超算和云计算：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;资源端：云端服务器供应软硬件资源（核芯+主板——》基本硬件管理层——》硬件利用层——》网络服务）
——》资源管理调度接口
用户端：核芯+主板——》基本硬件管理层——》硬件利用层——》网络服务——》命令行下即可管理调度或者图形界面下管理软件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chromeos是这样的：其中的图形界面部分不同于一般的系统，比较穿透。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;资源端：云端服务器供应软硬件资源
——》资源管理调度接口
用户端：核芯+主板——》基本硬件管理层——》硬件利用层
|——》网络服务
|——》基本图形系统——》图形界面
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无盘站&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;资源供应方：云端服务器供应软硬件资源
——》远程桌面
用户端：——》用户使用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无盘站：缺陷是原有协议穿透不了局域网&lt;/p&gt;

&lt;p&gt;超算和无盘站都是局域网，用高速网线连接的。&lt;/p&gt;

&lt;p&gt;张的透明计算：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;资源端：核芯+主板——》基本硬件管理层
|——》硬件利用层（meta os）
|——》网络服务（两个自写协议）
用户端：核芯+主板——》基本硬件管理层——》硬件利用层
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几种比较贴切的描述：&lt;/p&gt;

&lt;p&gt;网络版bois或者uefi，且加强了功能：极其底层的系统，在一般操作系统还没启动时，就已经启动，但又还没底层到主板上的引导程序。非主板烧录的，最接近底层硬件的操作系统。&lt;/p&gt;

&lt;p&gt;linux核心+网络服务 的弱化版：相比较linux的完整操作系统，其功能主要几种在资源组织和资源分配，功能上不如linux复杂，比如没必要管理声音和图形渲染。&lt;/p&gt;

&lt;p&gt;超级加强版 路由器操作系统。张之前就设计过一个 网络路由器系统，现在加强其功能了：硬件兼容更强，网络功能更强大，资源调度更透明方便，可调用的资源更多。&lt;/p&gt;

&lt;p&gt;民用版超算：非常像超算，但资源并不像超算那样集中在机房，内部用高速网线或连接线连接，而是可以使用广域网的资源（可以理解为只使用普通网线）。&lt;/p&gt;

&lt;p&gt;底层版分布式计算：可调用不仅仅是局域网的网络资源，而且是极其底层的资源，而不是被层层包装了的网络资源、云服务。&lt;/p&gt;

&lt;p&gt;可以说，meta os目前仍然是世界独步的，惟一无二的，有点接近的系统应该是 超算用的系统或者是 intel之类芯片设计商之前鼓吹的，嵌入主板的 微系统 。&lt;/p&gt;

&lt;p&gt;用一个通俗的比喻可能方便理解：&lt;strong&gt;在一片树林里扎篱笆，原来是在树枝上扎，后来有人在树干上扎，张的团队则是跑到根部扎。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在一片树林里扎篱笆，原来是在树枝上扎——普通分布式计算，一般僵尸网络&lt;/li&gt;
  &lt;li&gt;后来有人在树干上扎，——云计算&lt;/li&gt;
  &lt;li&gt;张的团队则是跑到根部扎——透明计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结为两句：系统很底层，管理的资源很广泛！&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;资源分布形式&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;不同计算机模式&lt;/th&gt;
      &lt;th&gt;家用电脑&lt;/th&gt;
      &lt;th&gt;chromeos&lt;/th&gt;
      &lt;th&gt;云服务&lt;/th&gt;
      &lt;th&gt;透明计算&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;存储&lt;/td&gt;
      &lt;td&gt;本地&lt;/td&gt;
      &lt;td&gt;远程，小部分本地缓存&lt;/td&gt;
      &lt;td&gt;远程，小部分本地缓存&lt;/td&gt;
      &lt;td&gt;远程，小部分本地缓存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;运算&lt;/td&gt;
      &lt;td&gt;本地&lt;/td&gt;
      &lt;td&gt;远程&lt;/td&gt;
      &lt;td&gt;远程&lt;/td&gt;
      &lt;td&gt;远程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;管理&lt;/td&gt;
      &lt;td&gt;本地&lt;/td&gt;
      &lt;td&gt;远程&lt;/td&gt;
      &lt;td&gt;远程&lt;/td&gt;
      &lt;td&gt;远程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;界面交互渲染&lt;/td&gt;
      &lt;td&gt;本地cpu或 图芯（尽可能强）&lt;/td&gt;
      &lt;td&gt;本地弱终端（不需要强）&lt;/td&gt;
      &lt;td&gt;本地终端（可强可弱）&lt;/td&gt;
      &lt;td&gt;本地终端（可强可弱）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;细化下轻本地端的资源分布&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;内容&lt;/th&gt;
      &lt;th&gt;远程管理&lt;/th&gt;
      &lt;th&gt;远程桌面&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;交互形式&lt;/td&gt;
      &lt;td&gt;命令行&lt;/td&gt;
      &lt;td&gt;图形交互界面&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;一般远程桌面：只是一个视频录像，所有的计算都是在远程完成。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;——》远程操作系统启动后，启用网络服务
——》远程操作系统图形界面 远程渲染后以 流 方式传输到本地
《——》传入本地或远程数据
——》调用远程操作程序
——》处理后，数据返回远程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有计算都是在远程完成，但减少了不必要的开支，更省网络流量。最大化集约化简化本地终端负载：前提是网络速度足够的情况下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;——》远程操作系统启动后，启用网络服务
——》调用远程操作界面，本地渲染，
    《——》传入本地或者远程数据，
——》调用远程操作程序，
    《——处理后，数据返回远程
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-9&quot;&gt;服务端资源管理&lt;/h3&gt;

&lt;p&gt;云计算、超算等，和这个问题解决方案应该是相同的。&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;如何解决硬件兼容问题&lt;/h3&gt;

&lt;p&gt;上面是简单的基本架构，如何实现呢？&lt;/p&gt;

&lt;p&gt;如果：世界上只有一种硬件，那这一步很好办。可惜，世界上各种硬件五花八门，驱动也是五花八门。兼容问题无穷无尽，层出不穷……&lt;/p&gt;

&lt;p&gt;硬件兼容问题有多么令人焦躁呢：linux创始人针对 硬件商 直接是举中指，爆粗口。&lt;/p&gt;

&lt;p&gt;如何解决？一般的思路是简化接口，只调用不同硬件底层较为通用的接口，而规避使用那些硬件特有的接口。或者更进一步，做一个兼容层（比如kde用phonon），来转换各个硬件不同的接口，规范使用这些硬件特有接口。&lt;/p&gt;

&lt;p&gt;但这只是理论上可行，现实中需要多少工作量呢？海量！&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;如何解决网络问题？&lt;/h3&gt;

&lt;p&gt;上面前团队成员暴露出来的信息看，好事多磨，在前期想偷懒，借用现成的东西，结果至少改了三次，还没真正踏进门里。最后估计是痛定思痛，干脆自己重写了两个协议才算搞定。&lt;/p&gt;

&lt;p&gt;参照清华的通报搞，很明显，在这家伙离去后，整个团队进行了重大革新。&lt;/p&gt;

&lt;p&gt;不同于&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;已有的远程启动(PXE)所使用的TFTP协议&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（单线程，速度不快，无法适应高速的界面初始化和大型任务的高速交互要求）。自己设计了一套也是底层的网络协议：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;高可靠网络协议和开发方法，研制了多操作系统远程加载协议（MRBP）和网络服务访问协议（NSAP），保证可靠的跨平台操作。
将网络互连平台由较高的网络层下降到计算机芯片和操作系统间的接口层&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;网速问题的解决：并发，分布式，实际上，只要能够流畅视频，就足够做所有事了，反正真正计算都是在服务端，转成视频流传输就很好看了。&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;用户如何管理资源&lt;/h3&gt;

&lt;p&gt;这相对来说已经非常简单了，主要是给各个操作系统做客户端的问题，虽然仍然是兼容性问题严重，但已有现成框架基本可以胜任，体力活。&lt;/p&gt;

&lt;p&gt;目前硬件情况和软件情况，注定还无法如 服务端那样做到非常底层，但理论上是可以做到底层裸主机+客户端，但要硬件生产商配合。&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;工程难度和工作量&lt;/h3&gt;

&lt;p&gt;就工程实现难度不低于一般的操作系统，比如linux，windows，主要是硬件方面的原因，但流行普及后，硬件兼容问题解决，会大幅度简化操作系统的设计。&lt;/p&gt;

&lt;p&gt;其实，这不是创不创新的问题，而是有没有实力的问题，很多人，都想要这么省略，甚至直接 核芯+主板+网络服务（路由器就这样的），但 核芯+主板 的产业并不掌握在自己手中，无法主导。&lt;/p&gt;

&lt;p&gt;这样不仅仅是实力，还有实战！是一手把这个极其繁重的工作给搞下来了。&lt;/p&gt;

&lt;p&gt;要搞定这么一个事情，需要涉及到海量的软硬件工作！&lt;/p&gt;

&lt;p&gt;这个工作量大不大？反正linux下wine搞了十几年，至今仍然只能半残废状态。&lt;/p&gt;

&lt;p&gt;另外，世界上有实力实现这个设想的，不多，也就一只手数得过来。&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;关于主动服务&lt;/h3&gt;

&lt;p&gt;其实就是 推送服务，在掌握了计算机主要资源之后，这个不难做到。&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;对张个人的理解&lt;/h3&gt;

&lt;p&gt;他应该是实战型+战略型的人物。&lt;/p&gt;

&lt;p&gt;人家是“工程院”院士！！不是中科院院士，擅长的是实现，是工程能力，实现能力，不是理论。论文？对搞工程的人来说，那都是事后有闲的时候补充论述。&lt;/p&gt;

&lt;p&gt;其所做的工作是完成了一整套完整的新型系统，这里面必然涉及到大量的技术问题和海量的工作量。能够完成，至少说明其管理能力卓越，解决问题能力卓越。&lt;/p&gt;

&lt;p&gt;结合其是解放军总装技术专家，实战部分应该是给保密单位研发操作系统了，所以大众无法了解。&lt;/p&gt;

&lt;p&gt;人家提出了一个有创新性的项目，并且有效组织了一群人，通过创新的办法克服各种工程难题，实现了。获重奖无可厚非，至于获得啥级别的，看其对评估单位的重要性，所以实至名归。&lt;/p&gt;

&lt;p&gt;看看清华的通报稿，个人觉得，光这两点，就够获重奖了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;成功研制出了具有独立知识产权的，运行在各种操作系统之下、主板之上的超级操作系统（Meta OS），使用户可以根据需要，通过近乎裸机的小终端设备获取不同操作系统平台的各类服务，从而大大降低了对用户终端的要求，解决了各种操作系统安全漏洞及多操作系统的兼容与跨平台问题。
该团队还提出了高可靠网络协议和开发方法，研制了多操作系统远程加载协议（MRBP）和网络服务访问协议（NSAP），保证可靠的跨平台操作，将网络互连平台由较高的网络层下降到计算机芯片和操作系统间的接口层&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;至于那些瞎鼓噪的，借用Gentoo创始人Daniel Robbins一句话：对于工程的事，请&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;show your code!&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 2015 Jan 16 12:25:20 +0800</pubDate>
        <link>http://jobinson.ga/%E6%8A%80%E6%9C%AF%E8%A7%86%E9%87%8E/2015/01/16/%E5%BC%A0%E5%B0%A7%E5%AD%A6%E8%8E%B7%E5%A5%96%E7%9A%84%E7%96%91%E9%97%AE/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E6%8A%80%E6%9C%AF%E8%A7%86%E9%87%8E/2015/01/16/%E5%BC%A0%E5%B0%A7%E5%AD%A6%E8%8E%B7%E5%A5%96%E7%9A%84%E7%96%91%E9%97%AE/</guid>
      </item>
    
      <item>
        <title>牛排和弓形虫</title>
        <description>&lt;p&gt;关于宠物和弓形虫和怀孕，我们太多误区了……&lt;/p&gt;

&lt;p&gt;首先，拿被列为弓形虫感染罪魁祸首的猫来说：&lt;strong&gt;不是每只猫都有弓形虫的，人家也是被感染的&lt;/strong&gt;，家养的大多数不出门的猫咪是没有的，的确，&lt;strong&gt;猫被感染后会终身携带弓形虫，但是排出体外只有一次，一生只有一次！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;即&lt;strong&gt;在被感染的几天内的首次代谢中随粪便排出，此后体内长期携带但不会再排出&lt;/strong&gt;。（狗根本就不是弓形虫的最终宿主，更不用提了。）&lt;/p&gt;

&lt;p&gt;而排出的弓形虫是不是马上就会感染人类呢？不是！&lt;strong&gt;弓形虫卵需要与空气接触并孵化约48小时才具有传染性&lt;/strong&gt;，也就是&lt;strong&gt;在这期间只要及时处理粪便，不给虫卵孵化的机会，传染完全可以避免。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;再说即使传染了，也不是洪水猛兽，因为&lt;strong&gt;弓形虫感染和起水痘一样，对人类而言，一生中不可能有第二次。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;绝对多数正常人在感染弓形虫后没有不适反应，少数身体虚弱的人会有类似发烧症状，随后&lt;strong&gt;人体自然产生抗体，并对其终身免疫。&lt;/strong&gt;这期间弓形虫对人体造成的伤害微乎其微，偶有特殊体质特殊案例其几率小于等于中五百万大奖。&lt;/p&gt;

&lt;p&gt;只有当弓形虫的初次感染者不巧处于怀孕初期，会有一定几率不幸使婴儿产生畸形或者流产等悲剧。免疫者则并不受影响。&lt;/p&gt;

&lt;p&gt;那我们来算算这个悲剧由猫狗造成的机率有多大？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一，你家的猫狗刚好不幸接触并感染了弓形虫。&lt;/li&gt;
  &lt;li&gt;第二，它唯一一次排出的带有弓形虫卵的粪便刚好在空气中足足孵化够了48小时成为具有传染性病原。&lt;/li&gt;
  &lt;li&gt;第三，你刚好触碰到了这些粪便并没有及时清洁而是将其带入体内。&lt;/li&gt;
  &lt;li&gt;第四，你之前养了很多年都没有机会传染过却正好在你刚怀孕的初期被第一次传染了……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;自己算算吧……中了的话可以去买彩票了。&lt;/p&gt;

&lt;p&gt;但是很多孕妇的确很不幸的感染了弓形虫，这种巧合也许的确成立，但是，但是，你真的确定你家的猫狗是这起不幸的罪魁祸首吗？！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;弓形虫感染源于生食习惯！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;绝大多数人感染弓形虫是因为生食。弓形虫卵广泛存在于很多动物体内，当人吃到这些没有被充分加热煮熟的含有弓形体包囊的动物组织，弓形虫自然病从口入了。
不过，虽然中国的食品卫生问题一直差强人意，但弓形虫感染率却是全世界最低的国家之一，大多在10%以下，这与中国人习惯熟食关系很大。&lt;/p&gt;

&lt;p&gt;英、美的成年人中，大约16-40%发生过感染，有的调查达到70%，欧洲大陆和拉丁美洲的成年人，50-80%发生过感染，法国人高达90%。法国人是众所周知活的在意，特拿自己的命当回事的人了，90%的人发生过感染，要是有大事的话，法国不早闹翻天了？而&lt;strong&gt;法国人这么高的感染率不是因为宠物，而是因为牛排！五成熟的牛排！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以怀孕的女人如果要杜绝弓形虫，要做的第一件事决不应该是把家里可怜的小猫小狗扫地出门。&lt;strong&gt;所有入口的食物确实洗干净煮熟了&lt;/strong&gt;才最要紧啊！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;人养猫养狗已有几千年历史,当真能对孕妇造成传说中的那么大的伤害的话,人早就应该认识到了,还用得着现在才瞎嚷嚷。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 2014 Nov 03 15:39:13 +0800</pubDate>
        <link>http://jobinson.ga/%E4%BF%9D%E5%81%A5/2014/11/03/%E7%89%9B%E6%8E%92%E5%92%8C%E5%BC%93%E5%BD%A2%E8%99%AB/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E4%BF%9D%E5%81%A5/2014/11/03/%E7%89%9B%E6%8E%92%E5%92%8C%E5%BC%93%E5%BD%A2%E8%99%AB/</guid>
      </item>
    
      <item>
        <title>利用metalsmith建静态网站</title>
        <description>&lt;mark&gt;特别提醒：不要把时间浪费在迁移平台上！&lt;/mark&gt;

&lt;p&gt;问题发生：
近一个月来，发现github的页面不会更新了，试了很多方式，都不更新——后来，才想起升级过git版本，新版本快速提交时对深度路径压缩不正确，导致出问题！解决办法是删了该目录后提交，再恢复该目录，再提交。&lt;/p&gt;

&lt;p&gt;折腾过程中，顺便就查了下各个语言的生成器，量真多，几乎每个语言都有若干个。
个人主要关注几个关注量大，且所用语言个人比较看好或者常用的。&lt;/p&gt;

&lt;p&gt;别人认为的槽点如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;ruby的中文编码问题：不支持中文的url路径？还有tag名称如果设置为中文，则不可以使用site.tags.TAG这种用法筛选文章，简直就是坑。&lt;/li&gt;
    &lt;li&gt;功能还是比较欠缺。只有一个分页器？还只能在index下分页？还有那个坑爹的liquid模板，不如直接上erb（当然作者是为了github的安全着想）。&lt;/li&gt;
    &lt;li&gt;不想装ruby&lt;/li&gt;
    &lt;li&gt;不熟悉ruby&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ruby&quot;&gt;ruby&lt;/h3&gt;

&lt;p&gt;jekyll 本人第一个深入使用的静态站生成器，使用量极高&lt;/p&gt;

&lt;p&gt;模板语言erb语法：属于Ruby标准库中的东西，不需要单独安装，模板中动态脚本的写法和JSP基本一个模子扒出来的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;% 写逻辑脚本(Ruby语法) %&amp;gt;
&amp;lt;%= 直接输出变量值或运算结果 %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;js&quot;&gt;js&lt;/h3&gt;

&lt;p&gt;有好多个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;metalsmith 全插件化，可从简到复杂，可定制性高&lt;/li&gt;
  &lt;li&gt;hexo 台湾一学生搞的，支持多线程生成，上百个文件只需要花数秒中就能生成，可自动提交，应该算js版的octopress。&lt;/li&gt;
  &lt;li&gt;harp 零配置起步——要不分支为sharp？&lt;/li&gt;
  &lt;li&gt;assemble&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;consolidate.js 模板中介&lt;/p&gt;

&lt;p&gt;liveload.js 根据更改，可即时刷新&lt;/p&gt;

&lt;p&gt;生成静态站：coffeescript&lt;/p&gt;

&lt;p&gt;前端：angular+动态响应&lt;/p&gt;

&lt;h3 id=&quot;coffeescript&quot;&gt;coffeescript&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;docpad&lt;/li&gt;
  &lt;li&gt;Wintersmith&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;其他&lt;/h3&gt;

&lt;p&gt;常见的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sphinx：python写的，经常用于生成技术文档&lt;/li&gt;
  &lt;li&gt;org-mode：其周边成熟度很高，个人用的也不少，不过，因为其对内嵌代码的设计有严重缺陷，而且广泛的使用率，使其改进的难度会变得极大！因此个人觉得除非开个分支改进否则很令人失望。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，还有几个特别的，比如直接用makefile来生成的&lt;/p&gt;

&lt;h2 id=&quot;metalsmith&quot;&gt;为何选用metalsmith&lt;/h2&gt;

&lt;p&gt;metalsmith的特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;全部插件化&lt;/li&gt;
  &lt;li&gt;核心很小，就一个调用程序，处理目录，输入输出的接口层（标准接口层），复制文件夹和文件到另一个文件夹和文件——此方法很值得借鉴！&lt;/li&gt;
  &lt;li&gt;灵活性大，可以生成各种类型项目：静态站，项目架构，生成工具，电子书，项目文档等，只要定义好模板。——相当于一个格式转换中心，从简单到复杂。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几个插件化比较彻底的项目：gulp 插件化构建测试套装工具，consolidate.js模板，metalsmith构建中心。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;安装环境&lt;/h2&gt;

&lt;p&gt;一，安装 node.js，安装方法见nodejs文档。&lt;/p&gt;

&lt;p&gt;二，然后，安装metalsmith外&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install metalsmith -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三，安装一些需要的插件：下面列出一些一般需要的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;assets：不转换、保持原样的部分&lt;/li&gt;
  &lt;li&gt;beautifier：为运行效率考虑，一般不需要。但为了方便检查代码生成结果，需要。&lt;/li&gt;
  &lt;li&gt;collections：分类&lt;/li&gt;
  &lt;li&gt;navigation：根据文件树输出导航&lt;/li&gt;
  &lt;li&gt;paginate：分页&lt;/li&gt;
  &lt;li&gt;permalinks：给网页一个固定链接&lt;/li&gt;
  &lt;li&gt;tags：文章标签&lt;/li&gt;
  &lt;li&gt;templates：布局模板&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;新建项目&lt;/h2&gt;

&lt;p&gt;可以从metalsmith源码中的example中复制一份，然后根据需要修改。&lt;/p&gt;

&lt;p&gt;也可以按照新建一个 nodejs 项目一样，新建一个，这样通用性较好。&lt;/p&gt;

&lt;p&gt;最终的文件结构可能如下：和一般的nodejs项目类似。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|– source/     需要被转换的内容
    |– content/
    |– images/
    |– styles/
    |_ scripts/
|– templates/    模板
|   |_ partials/
|– build/       生成的静态站点
    |– content/
    |– images/
    |– styles/
    |_ scripts/
|– node_modules/    开发所需的模块        
|– config.json
|– index.js     项目启动文件，metalsmith总控配置就放在这
|_ package.json    项目配置文件
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;packagejson&quot;&gt;项目所需插件：package.json&lt;/h2&gt;

&lt;p&gt;编辑 package.json，添加所需的依赖模块，然后安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install --save-dev metalsmith
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;indexjs&quot;&gt;配置：index.js&lt;/h2&gt;

&lt;p&gt;编辑 index.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Metalsmith = require(&#39;metalsmith&#39;);
Metalsmith(__dirname)
  .destination(&#39;./build&#39;)
  .use(drafts())
  .use(markdown())
  .use(permalinks(&#39;posts/:title&#39;))
  .use(templates(&#39;ejs&#39;))
  .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;各句解释：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;var Metalsmith = require(&#39;metalsmith&#39;);&lt;/code&gt; 调用 metalsmith&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;__dirname/src&lt;/code&gt; 指定需要转换的目录，比如此处是  &lt;code&gt;/src&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;.destination(&#39;./build&#39;)&lt;/code&gt; 指定输出到 build文件夹&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;.use(drafts())&lt;/code&gt; 使用 草稿箱&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;.use(markdown())&lt;/code&gt; 指定输入的格式为markdown文件&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;.use(permalinks(&#39;posts/:title&#39;))&lt;/code&gt; 设定固定链接形式&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;.use(templates(&#39;ejs&#39;))&lt;/code&gt; 指定输出时使用的转换模板ejs&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;.build();&lt;/code&gt; 生成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果不指定转换模板，则只是简单的 复制源码文件夹 到 输出文件夹。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;转换模板语言选用&lt;/h2&gt;

&lt;p&gt;metalsmith用consolidate.js，来作为各种模板语言中介。&lt;/p&gt;

&lt;p&gt;模板引擎会根据每个文件头部的 yaml格式 的 设定，进行转换。&lt;/p&gt;

&lt;p&gt;模板语言是生成的时候要运行的部分。&lt;/p&gt;

&lt;p&gt;js则是用户打开的时候才会用的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jade 语法和内容易混，缩进在不同编辑器中显示不一，特蛋疼&lt;/li&gt;
  &lt;li&gt;swig 语法借鉴jinja2 功能全，使用 &lt;code&gt;{}&lt;/code&gt; 标记&lt;/li&gt;
  &lt;li&gt;handlebars 非常少逻辑的模板，类似mustache，但比其稍强 使用 &lt;code&gt;{}&lt;/code&gt; 标记：没有if else for等，只有标签，标签用于替换各种东西。&lt;/li&gt;
  &lt;li&gt;Underscore 用的 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;ejs 无标签注记，无区块（有include） &lt;code&gt;&amp;lt;% code %&amp;gt;&lt;/code&gt; 筛选，可自定义标记，有客户端渲染器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为是静态站，此处不考虑模板引擎的效率&lt;/li&gt;
  &lt;li&gt;不知道会不会出现liquid的自身难以完整表达自身的问题？？？——liquid社区竟然认为那是一个功能，而不是缺陷！！！！&lt;/li&gt;
  &lt;li&gt;个人认为不应该给html增加一个标识符&lt;code&gt;{}&lt;/code&gt;，而应该使用原有的&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;，比如&lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;? ?&amp;gt;&lt;/code&gt;，目的是减少处理和识别复杂度。因此选用ejs。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;要是当初html设计成类似lisp那样的标识前置简化语法，可以省好多，没办法，html是事实标准，就只能跟标准妥协了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外，觉得php其实是一个伪装成编程语言的模板语言！！(带交互响应的)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php xxx ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果把php当成静态站的模板，需要剥离php的交互响应部分，把需要高度交互响应的，换用性能更强劲的部件。而不极限于php。&lt;/p&gt;

&lt;p&gt;技术演进：
php/asp+html+js+css，重心在php&lt;/p&gt;

&lt;p&gt;由于普及率问题，现在演变成了：
html+css+js+各种js模板。重心在js&lt;/p&gt;

&lt;h2 id=&quot;ejs&quot;&gt;ejs模板语言&lt;/h2&gt;

&lt;p&gt;ejs特点：不支持模板继承。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 用=号输出,会被escape转义编码
&amp;lt;%= 输出变量 %&amp;gt;
// 用“-”输出原始内容, 不会被escape
&amp;lt;%-输出变量是不会对 &amp;amp; 等符号进行转义的

&amp;lt;% if (names.length) { %&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;% names.forEach(function(name){ %&amp;gt;
      &amp;lt;li foo=&#39;&amp;lt;%= name + &quot;&#39;&quot; %&amp;gt;&#39;&amp;gt;&amp;lt;%= name %&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;% }) %&amp;gt;
  &amp;lt;/ul&amp;gt;
  &amp;lt;% } %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用 片段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
  &amp;lt;% users.forEach(function(user){ %&amp;gt;
    &amp;lt;% include user/show %&amp;gt;
  &amp;lt;% }) %&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;生成&lt;/h2&gt;

&lt;p&gt;使用nodejs来生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node index.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可用metalsmith，前提是配置内容写在 metalsmith.json &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;metalsmith
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;预览&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.robinthrift.com/posts/getting-to-know-metalsmith/&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 2014 Sep 13 12:15:31 +0800</pubDate>
        <link>http://jobinson.ga/%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%B7%AF/2014/09/13/%E5%88%A9%E7%94%A8metalsmith%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%B7%AF/2014/09/13/%E5%88%A9%E7%94%A8metalsmith%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/</guid>
      </item>
    
      <item>
        <title>静态网站变成动态网站</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;利用外部资源&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;添加评论系统&lt;/h3&gt;

&lt;p&gt;Jekyll生成的是静态网站，诸如评论、推荐、关注之类的功能，则需把各种各样第三方的功能部件加到你的博客中。&lt;/p&gt;

&lt;p&gt;与博客相关的主要有几类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;社会化评论：专门提供评论功能的网站，可以为博客增加评论功能，也可能附带着关注、相关文章、推荐等功能。国外的有disqus，国内的有友言，多说&lt;/li&gt;
  &lt;li&gt;社会化推荐：自动推荐相关文章（站内或站外）。国内的有友荐，无觅。Jekyll本身也可以实现站内文章推荐的功能。&lt;/li&gt;
  &lt;li&gt;社会化分享：将自己喜欢的网址分享给别人，通常附带推荐功能。国内的有加网 ，百度分享等。其中加网提供了划词分享功能。&lt;/li&gt;
  &lt;li&gt;社交网站联动：可以发布简短的动态。比如Twitter, Facebook, Google Plus, 新浪微博等网站。与博客的联动可以是自己发布博客动态，也可以是由别人推荐（这种方式即为社会化推荐）。
如果是自己发布动态，需要让别人能够方便的“关注/Follow”你，最好提供“一键关注的按钮”，或者提供连接能够让别人在这些网上方便的找到你。&lt;/li&gt;
  &lt;li&gt;社会化登录：就是OpenID或OAuth的集合。暂时不予考虑。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于存在着伟大的墙，只好尽量选择国内的社会化网络资源。对于更喜欢的国外的资源，尽量考虑如何不拖慢墙内用户的访问速度。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;评论功能&lt;/h3&gt;

&lt;p&gt;只选一个，选了友言。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;推荐功能&lt;/h3&gt;

&lt;p&gt;友言 本身就有了，所以不用去考虑。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;分享功能&lt;/h3&gt;

&lt;p&gt;友言本身也有了，不考虑了。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;流量分析和统计&lt;/h3&gt;

&lt;p&gt;第三方的流量分析和统计工具可以说是很多，国外的Google Analysis、SiteMeter和国内的百度统计、量子恒道统计等。&lt;/p&gt;

&lt;p&gt;为了减少翻墙需求，还是选择国内的吧，选了百度——不过我可以说百度做的真差么？&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;脱胎换骨&lt;/h1&gt;

&lt;h2 id=&quot;markdown&quot;&gt;换markdown渲染核心&lt;/h2&gt;

&lt;p&gt;注：由于一些代码在liquid的转码中出现问题，因此，有必要对照着源码，&lt;a href=&quot;https://github.com/jobinson99/jobinson99.github.io&quot;&gt;源码库在此&lt;/a&gt;
jekyll2默认用的 kramdown，换！
github网站提供的编译器版本比较注重安全性，因此会关闭一些功能。&lt;/p&gt;

&lt;p&gt;为了解决这些问题，改用pandoc渲染，相应的：关闭掉github本身提供的渲染功能。
获得的好处：文内导航自动生成，支持数学公式，支持表格等！&lt;/p&gt;

&lt;p&gt;另外，最新的bootstrap也基于jekyll了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jekyllrb.com/docs/plugins/&quot;&gt;插件安装参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;公式解决：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;js&quot;&gt;利用js使页面动态响应&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;简单的根据用户显示内容&lt;/li&gt;
  &lt;li&gt;从别的网站获取新闻，用户每次查看都是最新新闻&lt;/li&gt;
  &lt;li&gt;在线编辑&lt;/li&gt;
  &lt;li&gt;提交成果到成果库：利用git.js&lt;/li&gt;
  &lt;li&gt;在线交流：together.js&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;添加动态编程环境&lt;/h2&gt;

&lt;p&gt;codemirror？制作一个编程环境&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;在线提交&lt;/h2&gt;

&lt;p&gt;利用 github.js 实现在线提交！——但安全性较差，一般只用在本地js编程环境下，当然，如果有隐藏办法也是可以的，但防君子不妨小人！&lt;/p&gt;

</description>
        <pubDate>Mon, 2014 Sep 01 20:01:01 +0800</pubDate>
        <link>http://jobinson.ga/%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%B7%AF/2014/09/01/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%8F%98%E6%88%90%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%B7%AF/2014/09/01/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%8F%98%E6%88%90%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99/</guid>
      </item>
    
      <item>
        <title>易码肆的码道技巧</title>
        <description>&lt;p&gt;既然选用码道来作为主要的文档格式，那么一个适手的工具就是必须的了。本人选用的是：易码肆（emacs）+码道中文模式（markdown-zh）&lt;/p&gt;

&lt;p&gt;码道中文模式是我个人改造的，&lt;a href=&quot;https://github.com/i-org/markdown-mode-zh&quot;&gt;可在此下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;另外，为了让生产线更高效，还有一个中文版的成果管理工具：&lt;a href=&quot;https://github.com/i-org/egg-zh&quot;&gt;鹅哥哥成果管理&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;snippet&quot;&gt;利用snippet&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://mad4a.me/2012/08/02/emacs-summary-cont/#outline_2&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;添加几个常用的代码片段&lt;/h3&gt;

&lt;p&gt;新建几个snippet，内容如下：&lt;/p&gt;

&lt;p&gt;插入头部：h（还有大bug）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-
# name: head-info
# --
---
layout: post
title: &quot;`(mis-remove-date (mis-extract-file-name (buffer-name)))`&quot;
date: `(format-time-string &quot;%Y-%m-%d %H:%M:%S %z&quot;)`
description: &quot;&quot;
categories: `(buffer-file-name)`
tags: [${1:话题}]
lastmod: 
--- 

$0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我的看法：a&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-
# name: aside
# --
&amp;lt;aside&amp;gt;&amp;lt;b&amp;gt;黑传说看法：&amp;lt;/b&amp;gt;${1:}&amp;lt;/aside&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加粗+背景色：bbc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-
# name: bold+background-color
# --
&amp;lt;b style=&quot;background-color:${1:};&quot;&amp;gt;${2:文本}&amp;lt;/b&amp;gt; $0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;背景色:bc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-
# name: background-color
# --
&amp;lt;span style=&quot;background-color:${1:};&quot;&amp;gt;${2:文本}&amp;lt;/span&amp;gt; $0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字体颜色:fc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-
# name: font-color
# --
&amp;lt;span style=&quot;color:${1:};&quot;&amp;gt;${2:文本}&amp;lt;/span&amp;gt; $0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;高亮文本：m&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-
# name: highlighted text
# --
&amp;lt;mark&amp;gt;${1:文本}&amp;lt;/mark&amp;gt; $0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;圈字：q&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-
# name: border-around
# --
&amp;lt;span style=&quot;border: 2px solid black; border-radius: 30px;&quot;&amp;gt;${1:圈字}&amp;lt;/span&amp;gt; $0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;简化图片插入操作&lt;/h3&gt;

&lt;p&gt;图片路径安排：每篇文章一个图片文件夹&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;| --- _posts
|       | --- 2012-07-31-hello-world-again.md
|       | --- 2012-08-01-emacs-summary.md
|       | --- 2012-08-02-emacs-summary-cont.md
|
| --- assets
|       | --- images
|       |       | --- emacs-summary
|       |       |       | --- emacs-screenshot.png
|       |       |
|       |       | --- emacs-summary-cont
|       |       |       | --- post-meta-screenshot.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要达到的目的：仅仅用上下方向键选择图片。&lt;/p&gt;

&lt;p&gt;需要创建两个文件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;修改emacs 配置文件：用于获取图片路径和列出图片&lt;/li&gt;
  &lt;li&gt;yasnippet文件：用于调用上面的配置文件中设定的函数，选择图片。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;姑且把emacs配置文件单独存为一个 el文件，命名为 &lt;code&gt;markdown-image-select.el&lt;/code&gt; 填入以下内容：&lt;/p&gt;

&lt;p&gt;yasnippet文件， 姑且命名为 &lt;em&gt;i&lt;/em&gt;，填入内容：（注意不要换行）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![${1:$$(yas-choose-value (mis-yield-choices (buffer-file-name)))}](/static/images/`(mis-get-directory-from-bufname (buffer-file-name))`/$1)$0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，修改下emacs的配置，调用 &lt;code&gt;markdown-image-select&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最后一步，重启emacs&lt;/p&gt;

</description>
        <pubDate>Thu, 2014 Jul 24 22:01:11 +0800</pubDate>
        <link>http://jobinson.ga/%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%B7%AF/2014/07/24/%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E7%94%9F%E6%88%90%E5%99%A8/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%B7%AF/2014/07/24/%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      </item>
    
      <item>
        <title>大人格和小人格</title>
        <description>&lt;p&gt;不可以用对匹夫匹妇的道德水平来要求在历史上有重大影响的人物。&lt;/p&gt;

&lt;p&gt;和尚应该吃肉，批量饲养的肉应该吃；但不能乱吃肉，野生的一般不吃，但严重破坏生态平衡的要吃。&lt;/p&gt;

&lt;p&gt;理由有三：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;现在大部分肉都是饲养的，这些肉的销售，可以养活了好几家人，甚至几十家，几百家人。&lt;/li&gt;
  &lt;li&gt;这些肉不断被高速消化，会促进这些生物本身的生育和长成。&lt;/li&gt;
  &lt;li&gt;吃肉有助于身体发育，有了强健的身体，有助于创造更多的价值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，帮助消化这些肉，不仅不会犯杀生，甚至有助于 乐生 。&lt;/p&gt;

&lt;p&gt;这是大仁！&lt;/p&gt;

&lt;p&gt;帮助植物或者动物繁育，帮助人过日子，或者帮人能养育人口，这些都是大仁！&lt;/p&gt;

&lt;p&gt;大仁可不拘戒律，戒律只是为了给那些自控差的人用的，毕竟绝大部分人都是自控差的。&lt;/p&gt;

&lt;p&gt;追求大仁者，有可能是因为本身小仁无法追求，比如我，然后移情到大仁上，或者说是不想众生和我一样遭遇那样的困苦，因此想在自己能力范围内，帮大众规避这种困难。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;道德困扰了中国人&lt;/h2&gt;

&lt;p&gt;原文作者李敖，我把里面那些偏执、不符合历史和现实的东西改写掉。&lt;/p&gt;

&lt;p&gt;中国人在几千年残酷的生活中，总结出了一套有助于改善自身生存的规则，演化为日常生活中的伦理道德。&lt;/p&gt;

&lt;p&gt;而伦理道德被发明以后，又具备了自身的独立生命力，被经常用来判断一个人或者一件事，甚至极端到“泛道德主义”，就是什么都要道德一下，该道德的固然道德，不道德的也照道德不误，道德定了。&lt;/p&gt;

&lt;p&gt;流风所至，人们经常会把一切都先来个二分法，什么都先劈头来个大分类，像小孩子问“好人” “坏人”一样，先用“道德的”或“不道德的”来检查一切。 &lt;/p&gt;

&lt;p&gt;这种极端做法，使人不太承认在“道德的”或“不道德的”的以外，还有一种“跟道德不相干的”第三势力存在，甚至还想把第三势力也道而德之：&lt;/p&gt;

&lt;p&gt;例如“玉”有什么道德不道德？可是中国人说“玉石之美有五德”；“鸡”有什么道德不道德？可是中国人说“鸡有五德”；“天地”有什么道德不道德？
可是中国人说“天地不仁”或“天地大德”。……&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;仁困扰了孔夫子&lt;/h3&gt;

&lt;p&gt;从“论语”里，我们经常可以发现这种困扰的文字。
以管仲的人格问题为例：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;子贡曰：“管仲非仁者与？桓公杀公子纠，不能死，又相之。”
子曰：“管仲相桓公，霸诸侯，一匡天下，民到与今受其赐。微管仲，吾其被髡左衽矣！岂匹夫匹妇之为谅也，自经于沟渎而莫之知也！”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;翻译：子贡问：“管仲的人格有问题罢？齐桓公杀了公子纠，管仲是公子纠的人，他不能为公子纠殉难，反倒替齐桓公当家，管仲的人格有问题罢？”
孔夫子答：“管仲帮齐桓公，尊王攘夷，一统天下，老百姓直到今天还得到他的好处，没管仲，连我今天都要因亡国而做胡人打扮了！管仲是大处着眼的人，他哪里会像一般匹夫匹妇一样，没没无闻去殉难，没没无闻的去守那些匹夫匹妇的人格标准呢！”&lt;/p&gt;

&lt;p&gt;子贡的困扰，同样发生在子路身上： &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;子路曰：“桓公杀公子纠，召忽死之，管仲不死，曰：未仁乎？”
子曰：“桓公九合诸候，不以车兵，管仲之力也。如其仁！如其仁！”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;翻译：子路问：“齐桓公杀了公子纠，召忽殉难，为公子纠死了，管仲却偷生，人格有问题罢？”
孔夫子答：“齐桓公多次召集群雄，不用武力，全是管仲的功劳。管仲是大处着眼的人，这就是他伟大的人格啊！非常伟大！”&lt;/p&gt;

&lt;p&gt;孔夫子给两个学生的答案，都是在说管仲具有和普通人不一样的 “仁” 。&lt;/p&gt;

&lt;p&gt;孔夫子死后，后代的人，几乎全在孔夫子思想大磁场下做“指南针”，一直不敢“代圣人立言”，以致孔夫子的思想，非但不能被“继绝学”，反倒其学愈继愈绝。
千百年来，他的思想一直被匹夫匹妇思想家解释着，自然百孔千疮、一丘之貉。 &lt;/p&gt;

&lt;p&gt;在答复两个学生的“道德审判”里，孔夫子把“仁”字来做“统摄诸德完成人格”的总辞汇，但没有区分“大仁”和“小仁”。
而且，随着时间的推移，这个“仁”字内涵是有变化的。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;大人格与小人格&lt;/h3&gt;

&lt;p&gt;孔夫子的“仁”，包含着“人格的两层面”：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第一层面是“管仲的层面”：是大人物的层面、是特立独行的层面、是大无畏的层面、是“虽千万人，吾往矣！”的层面；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第二层面是“匹夫匹妇的层面”：是小市民的层面、是随波逐流的层面、是依附权势的层面、是“庸德之行，庸言之谨”的层面。 &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;大人格：管仲的层面&lt;/h3&gt;

&lt;p&gt;“管仲的层面”所表现的人格，叫“大人格”；“匹夫匹妇”所表现的，叫“小人格”。
“大人格”的表现因为是特立独行的、是大无畏的、是“虽千万人，吾往矣！”的，自然跟“小人格”的表现冲突，尤其是“大人格”尚未功成名就前，这种冲突，更为显著。&lt;/p&gt;

&lt;p&gt;管仲在尚未功成名就前，与朋友做生意，要多分钱，在“小人格”标准，这是吃人；
管仲为朋友办事，给办砸，在“小人格”标准，这是害人；
管仲同朋友出征，作战时退后，凯旋时在前，在“小人格”标准，这是胆怯；
管仲在公子纠被杀，朋友殉难，反倒投奔敌人，在“小人格”标准，这是无耻。……&lt;/p&gt;

&lt;p&gt;即使在管仲功成名就以后，在“小人格”标准下，他的作风，也可议颇多，孔夫子以“小人格”标准看管仲，就骂出“管仲之器小哉！”的话、就骂出“管氏而知礼，孰不知礼！”的话。&lt;/p&gt;

&lt;p&gt;管仲的一切不合“小人格”标准的行径，虽为大家所不谅，但他的朋友鲍叔牙却一直信任他、一直让他。
最妙的，在管仲临死前，齐桓公来问他谁做他的接班人，他竟不推荐曾推荐他的鲍叔牙，理由是鲍叔牙不能搞政治。
这在“小人格”的标准下，十足是忘恩负义了，但在“忠于为国，不私其友”的“大人格”标准下，管仲却能天下为公。
管仲所以为管仲、所以伟大，就在于这里！ &lt;/p&gt;

&lt;p&gt;以孔夫子的深明大义，都难免用过“小人格”标准看管仲，可见“小人格”标准在社会上多么流行。
“小人格”标准是“匹夫匹妇的层面”，是随波逐流的、依附权势的、“庸德之行，庸言之谨”的，这种标准的泛滥下，胸怀“大人格”标准的英雄豪杰，都会长期遭到舆论、谣言、群众、世俗的打击。&lt;/p&gt;

&lt;p&gt;所以，“父子责善” 的贤人 匡章，全国说他不孝；“弟死不葬”的志士张良，社会说他不仁；周公旦 被诬不利孺子；直不疑 被诬与嫂通奸；马援 被诬贪污；张自忠被骂汉奸，蒙羞六七载；岳飞不得昭雪，沉冤二十年。
……&lt;/p&gt;

&lt;p&gt;多少大丈夫，在“小人格”标准下，都变成了“人格有问题”的下三烂，这种不公道局面的形成，毛病出在哪儿呢？ &lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;小人格：匹夫匹妇的层面&lt;/h3&gt;

&lt;p&gt;毛病出在“匹夫匹妇的层面”。&lt;/p&gt;

&lt;p&gt;“匹夫匹妇的层面”所见者小，这种层面的“道德判断”，只是小市民的横断面，小市民只会从个人的利益、家族的利益、朋友的利益、宗教的利益、职业的利益、帮派的利益和党的利益检定人格，
他们要求的人格标准也只是他们小圈圈的人格标准，在小圈圈内，他们不失为好丈夫、好朋友、好龙头、好领袖，但在小圈圈外，他们都是魔鬼。&lt;/p&gt;

&lt;p&gt;黑龙会头子、黑手党教父在小圈圈内是最够朋友的，但在小圈圈外是无恶不作的；
公孙弘小圈圈外内是第一流的孝子、第一流节俭的人，但在小圈圈外，他是第一流的奸臣。&lt;/p&gt;

&lt;p&gt;用“小人格”标准看，甘地最不够朋友，因为他主张人要为真理牺牲朋友，甘地的人格有问题！
用 “小人格”标准看，文天祥忠而忘孝、生活奢侈，文天祥的人格也有问题！ &lt;/p&gt;

&lt;p&gt;因为社会上匹夫匹妇多，检定人格的标准，自也就匹夫匹妇化，匹夫匹妇只注重小团体利益，缺少对社会整体的真理与正义；
只会以偏盖全，缺少大处着眼。
所以，常常有很好很好的人，反被视为坏蛋、被视为“人格有问题”。 &lt;/p&gt;

&lt;p&gt;很坏很坏的人，发现匹夫匹妇的“小人格”标准原来这样，发现匹夫匹妇只注意“小人格”而不知“大人格”，于是他们便从“小人格”毁掉异己、斗臭政敌、破坏“非我族类”的“大人格”形象。
他们的方法是迂回的：报纸的围剿、口语的相传、朋友的诬控、妻子的伪证、罪名的离奇、审判的丑化等等，都是他们的拿手好戏。 &lt;/p&gt;

&lt;p&gt;结果是，“道德迷”的中国人，很容易便在“道德判断”上中计，硬说谁谁谁“人格有问题”。然后喊打喊杀，口水直溅。 &lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;管仲的小人格也没问题&lt;/h3&gt;

&lt;p&gt;具有“大人格”抱负的英雄豪杰，难道他们的“小人格”方面真有问题吗？事实绝非如此。
再以管仲为例，在“小人格”标准下看管仲，这个人太菜了，但是幕后真相是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;吾始困时，尝与鲍叔贾，分财利多自与，鲍叔不以我为贪，知我贫也；
吾尝为鲍叔谋事而穷困，鲍叔不以我愚，知时有利不利也；
吾尝三仕三见逐于君，鲍叔不以我为不肖，知我不遭时也；
我尝三战三走，鲍叔不以我为怯，知我有老母也；
公子纠败，召忽死之，吾幽囚受辱，鲍叔不以我为无耻，知我不羞小节而耻功名不显于天下也。
—-生我者父母，知我者鲍子也。 &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这段动人的话，告诉了我们，具有“大人格”胸怀的，他的“小人格”方面，其实没有问题，只是不为匹夫匹妇所知罢了！ &lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;“虽千万人，吾往矣！”&lt;/h3&gt;

&lt;p&gt;一个人走上特立独行的、大无畏的、“虽千万人，吾往矣！”的长路，他的人格，早就在“匹夫匹妇的层面”之上，不是人间大智大仁大勇的，不会这样走；
不是道德至高人品至善的，不会这样走；不是“大人格”涵盖了“小人格”的，不会这样走。 &lt;/p&gt;

&lt;p&gt;绝大部分人千百年来讲道德，却讲错了道德，只讲到独善其身的“乡愿”道德，却没讲到兼善天下的“狂狷”道德。
结果是，中国思想中的“虽千万人，吾往矣！”的理论谁都会说，却很少人敢做，因为一做就倒霉。&lt;/p&gt;

&lt;p&gt;孔夫子攻击“乡愿”，但是千百年下来，人人是“乡愿”，并且以“乡愿”身份，骂“虽千万人，吾往矣！”的少数人“人格有问题”。&lt;/p&gt;

&lt;p&gt;我们不要忘记：在举国滔滔，为阉党拍马祝寿的时候，顾宪成不肯签名，这是何等人格！
在举国滔滔，为国民党歌功颂德的时候，党外人士敢捋虎须，这是何等人格！ &lt;/p&gt;

&lt;p&gt;我们不要忘记：检定人格的第一标准，是看一个人有没有特立独行的、大无畏的、“虽千万人，吾往矣！”的“大人格”，而不是看他有没有匹夫匹妇的“小人格”。
不确认出这种检定标准，人的道德不会有进步，人将永远在滑头的道德水平上做小市民，人永远不会做大丈夫。 &lt;/p&gt;

&lt;p&gt;一九八一年四月六日&lt;/p&gt;

</description>
        <pubDate>Mon, 2014 Jul 21 00:00:00 +0800</pubDate>
        <link>http://jobinson.ga/%E6%B6%85%E7%A3%90/2014/07/21/%E5%A4%A7%E4%BA%BA%E6%A0%BC%E5%92%8C%E5%B0%8F%E4%BA%BA%E6%A0%BC/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E6%B6%85%E7%A3%90/2014/07/21/%E5%A4%A7%E4%BA%BA%E6%A0%BC%E5%92%8C%E5%B0%8F%E4%BA%BA%E6%A0%BC/</guid>
      </item>
    
      <item>
        <title>【公开课】常见编程语言风格</title>
        <description>&lt;p&gt;下面应该越来越少人看了，只要扫一眼有个印象就行，不需要在这里掌握。&lt;/p&gt;

&lt;h2 id=&quot;c&quot;&gt;C&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.buildyourownlisp.com/&quot;&gt;参考：用c来构建一个链码系统&lt;/a&gt; &lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;变量&lt;/h3&gt;

&lt;p&gt;通过 事先定义（statement） 末尾需要一个分号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int count;
int count = 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内建数据类型：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;标识&lt;/th&gt;
      &lt;th&gt;数据类型&lt;/th&gt;
      &lt;th&gt;示例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;void&lt;/td&gt;
      &lt;td&gt;空类型&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;char&lt;/td&gt;
      &lt;td&gt;单字符型/Byte&lt;/td&gt;
      &lt;td&gt;char last_initial = ‘H’;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;int&lt;/td&gt;
      &lt;td&gt;整数&lt;/td&gt;
      &lt;td&gt;int age = 23;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;long&lt;/td&gt;
      &lt;td&gt;长整数&lt;/td&gt;
      &lt;td&gt;long age_of_universe = 13798000000;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;float&lt;/td&gt;
      &lt;td&gt;带小数数字&lt;/td&gt;
      &lt;td&gt;float liters_per_pint = 0.568f;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;double&lt;/td&gt;
      &lt;td&gt;双精度带小数数字&lt;/td&gt;
      &lt;td&gt;double speed_of_swallow = 0.01072896;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-1&quot;&gt;函数定义&lt;/h3&gt;

&lt;p&gt;一对大括号+逗号分隔内部变量+分号，return用于设定输出结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int math-add(int x, int y) {
    int result = x + y;
    return result;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;math-add(10, 18)
&amp;gt; 28
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了方便调用计算结果，把结果存入变量中 一对括号+逗号分隔内部变量+分号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int add4reuse = math-add(10, 18);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题：以上步骤都是在内存中操作，重启机器就没了，如果有需要，则可以进一步写入文件或者数据库中，实现持久性存储。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;结构定义：用于新建 类&lt;/h3&gt;

&lt;p&gt;类 = 多变量绑在一起，变成一个包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct {
    float x;
    float y;
  } point;   /point是新建框架的名字
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建框架的使用。设定实例：实例+点+变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;point p;
p.x = 0.1;
p.y = 10.0;

float length = sqrt(p.x * p.x + p.y * p.y);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;pointer-&quot;&gt;pointer 系统：指针&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;int* x;   /这样的写法对新手来说清晰
int *x;   /这是日常的写法 

/* A pointer to a new empty Qexpr lval */
lval* lval_qexpr(void) {
  lval* v = malloc(sizeof(lval));   /
  v-&amp;gt;type = LVAL_QEXPR;    / 指针属性：类型
  v-&amp;gt;count = 0;    /指针属性：
  v-&amp;gt;cell = NULL;   /指针属性：
  return v;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;char&quot;&gt;字串 &lt;code&gt;char*&lt;/code&gt;&lt;/h3&gt;

&lt;h3 id=&quot;array&quot;&gt;数组 &lt;code&gt;array&lt;/code&gt;&lt;/h3&gt;

&lt;h3 id=&quot;section-3&quot;&gt;条件操控&lt;/h3&gt;

&lt;p&gt;if+括号+若有多个条件，则用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 并列 或 &lt;code&gt;||&lt;/code&gt; 或 分隔&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; if (x &amp;gt; 10 &amp;amp;&amp;amp; x &amp;lt; 100) {
   puts(&quot;x 大于10 且小于100!&quot;);
 } else {
   puts(&quot;x 小于11或者大于99!&quot;);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;循环&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;while&lt;/code&gt; 下面表示从10往1算，递减&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;for &lt;/code&gt;下面表示从0到9算，递增&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  int i = 10;
    while (i &amp;gt; 0) {
      puts(&quot;Loop Iteration&quot;);
      i = i - 1;
    }
    
    for (int i = 0; i &amp;lt; 10; i++) {
      puts(&quot;Loop Iteration&quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;宏&lt;/h3&gt;

&lt;p&gt;用在处理重复性操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define MACROXXX(args, cond, err) if (!(cond)) { xxx(args); return lval_err(err); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 #define 来定义，三个参数分别代表：参照参数，条件，出错信息。整个宏代表：如果条件不成立，则 执行xxx(参照参数)，并输出 出错信息。
注：此处没设定如果条件成立的处理方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 调用 */
MACROXXX(a, (a-&amp;gt;count == 1                 ), &quot;Function &#39;xxx&#39; passed too many arguments!&quot;);
MACROXXX(a, (a-&amp;gt;cell[0]-&amp;gt;type == LVAL_QEXPR), &quot;Function &#39;xxx&#39; passed incorrect type!&quot;);
MACROXXX(a, (a-&amp;gt;cell[0]-&amp;gt;count != 0        ), &quot;Function &#39;xxx&#39; passed {}!&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;c-1&quot;&gt;C的一些机制&lt;/h3&gt;

&lt;p&gt;调-返 （callback）：用于后台加载，后台运算不错，但由于并行计算时代的到来，这个很好的机制变成了最容易出问题的地方。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;设计全面的语言：通链&lt;/h2&gt;

&lt;p&gt;主要的语法特征：前置标识&lt;/p&gt;

&lt;p&gt;机制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;灵活的机制兼顾编写效率和运行效率：
    &lt;ul&gt;
      &lt;li&gt;运作机制：代码可立刻解析运行，从而提升编写效率。也可编译后运行，提升运行效率。&lt;/li&gt;
      &lt;li&gt;类型系统：可以不预先设定数据操作类型，让系统自动辨识，提升代码编写效率。也可以在后期优化时指定数据类型，提升运行效率。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;前瞻性的设计：资源回收机制，总分法，并行计算等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特点：设计非常完备，而且，这样的完备设计已经稳定标准化了多年。&lt;/p&gt;

&lt;p&gt;缺点：普及度不高，而且，因为设计太过完备，难免隐藏不少问题，只是因为应用太少，这些问题暴露的不全。&lt;/p&gt;

&lt;p&gt;对于lisp，只需要学习其设计，而不需要学习其具体的编程&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;难读天书：简符码&lt;/h2&gt;

&lt;p&gt;目的在于提供快速简便的拣选。&lt;/p&gt;

&lt;p&gt;虽然难懂，但因为应用比较多，所以还是需要掌握部分规律。&lt;/p&gt;

&lt;h2 id=&quot;jshtmlcss&quot;&gt;通用常见型：js+html+css特混编队&lt;/h2&gt;

&lt;p&gt;这是目前最流行，也最通用的，虽然效率还不太好，但随着其普及，这方面的改善一直在进行中……&lt;/p&gt;

&lt;p&gt;最主要部分是js，其越来越全能。&lt;/p&gt;

</description>
        <pubDate>Mon, 2014 May 12 22:38:00 +0800</pubDate>
        <link>http://jobinson.ga/%E6%8A%80%E6%9C%AF%E6%99%AE%E5%8F%8A/2014/05/12/%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E6%8A%80%E6%9C%AF%E6%99%AE%E5%8F%8A/2014/05/12/%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC/</guid>
      </item>
    
      <item>
        <title>【公开课】编程语言解剖</title>
        <description>&lt;p&gt;杂七杂八之后，接下来，说说能够组合出程序的编程语言：&lt;/p&gt;

&lt;p&gt;先说说这世界上有啥编程语言。对于正常人而言，计算机编程语言大概就是下面这四种类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;计算机电子信号——&amp;gt;编码为二进制——&amp;gt;助记符（汇编）——&amp;gt;抽象以方便人类操作的语言（比如C）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于前面三种，现在一般人都不需要去直接接触，对于第四种，就是我们日常需要接触掌握的，第四种是非常丰富的，有各种各样，而且，日常编程生产作业中，都是不可避免地需要同时掌握好几个编程语言，才能写出一个可用的程序的，因此，为了快速掌握它们，需要了解它们的一些共有规律。&lt;/p&gt;

&lt;p&gt;另外，对于有些特殊要求的，比如前面说到的瘫痪的人，可能其计算机编程语言就演变成如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;计算机电子信号——&amp;gt;编码为二进制——&amp;gt;助记符（汇编）——&amp;gt;摩斯码或者可能的盲文编程语言（目前还不存在这种语言）
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;为什么会有这么多的语言呢？&lt;/h3&gt;

&lt;p&gt;从打孔机时代一路走来&lt;/p&gt;

&lt;p&gt;为了表达 &lt;code&gt;1 + 2 + ... + 10 = 55&lt;/code&gt; 并打印出结果，需要：&lt;/p&gt;

&lt;p&gt;其特点：操作 操作对象 内存位置。再复杂的逻辑，都可以简化为如此形式。
初看运算范围是有限的：不超过8位二进制所能表达的范围，当然，有办法表达所有数字，就是运用科学计数法。
这是没有资源回收的版本，会导致有三个内存位置一直被占用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;00110001 00000000 00000000
00110001 00000001 00000001
00110011 00000001 00000010
01010001 00001011 00000010
00100010 00000010 00001000
01000011 00000001 00000000
01000001 00000001 00000001
00010000 00000010 00000000
01100010 00000000 00000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每句解释：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;[结果]把数字0 存放到 内存位置 0 中&lt;/li&gt;
  &lt;li&gt;[运算材料]把数字1 存放到 内存位置 1 中&lt;/li&gt;
  &lt;li&gt;[运算]把 内存位置1的&lt;strong&gt;值&lt;/strong&gt; 存放到内存位置 2 中&lt;/li&gt;
  &lt;li&gt;[设定范围] 内存位置 2 的值 减去 11&lt;/li&gt;
  &lt;li&gt;[设定范围] 若 内存位置2的值为0 ，则跳转到第九步&lt;/li&gt;
  &lt;li&gt;[累计结果]把内存位置1的值 加入到内存位置 0 中&lt;/li&gt;
  &lt;li&gt;[递增] 把内存位置1的值 加1&lt;/li&gt;
  &lt;li&gt;[跳转]继续第三步&lt;/li&gt;
  &lt;li&gt;[输出]把 位于内存位置 0 的值 输出。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;进一步发展编程语言，利用借记符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Set “total” to 0
 Set “count” to 1
[loop]
 Set “compare” to “count”
 Subtract 11 from “compare”
 If “compare” is zero, continue at [end]
 Add “count” to “total”
 Add 1 to “count”
 Continue at [loop]
[end]
 Output “total”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中文解释：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;设 “总值” 初始值为 0&lt;/li&gt;
  &lt;li&gt;设 “累加值”初始值为 1&lt;/li&gt;
  &lt;li&gt;[循环执行]&lt;/li&gt;
  &lt;li&gt;设 “范围” 为 “累加值”&lt;/li&gt;
  &lt;li&gt;“范围” - 11&lt;/li&gt;
  &lt;li&gt;如果 “范围” = 0 转到 [结果]&lt;/li&gt;
  &lt;li&gt;总值 = 累加值&lt;/li&gt;
  &lt;li&gt;累加值 = 累加值 + 1&lt;/li&gt;
  &lt;li&gt;转到 [循环执行]&lt;/li&gt;
  &lt;li&gt;[结果]&lt;/li&gt;
  &lt;li&gt;输出 “总值”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现代编程语言 js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var total = 0, count = 1;
while (count &amp;lt;= 10) {
  total += count;
  count += 1;
}
console.log(total);
// → 55
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，理论上还可以进一步简化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(sum(range(1, 10)));
// → 55
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：8位二进制可以表达多少？
示例：13，用二进制表示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  0   0   0   0   1   1   0   1
128  64  32  16   8   4   2   1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是： &lt;code&gt;00001101&lt;/code&gt; 或者 &lt;code&gt;8+4+1=13&lt;/code&gt; 。依此类推，8位数可以一共表达256，ascii的基础码共128（编码还不够简约，其实26个大写字母可以只用加一位即可判断，不需要硬编码进去），包含扩展码后共256个。&lt;/p&gt;

&lt;aside&gt;个人观点：其实，汉字如果用笔画+位置来编码的话，也不需要那么多：假设10个基本笔画，42个位置信息，则可以编码 10^42=10e+42&lt;/aside&gt;

&lt;h3 id=&quot;section-1&quot;&gt;语言发展的动力&lt;/h3&gt;

&lt;p&gt;编程语言是不完美的，现实情况的变化，编程语言也是需要不断发展的。&lt;/p&gt;

&lt;p&gt;编程语言进化的动力，就是不满！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Algol: 汇编太底层了。&lt;/li&gt;
    &lt;li&gt;Pascal: Algol语言缺少足够的数据类型。&lt;/li&gt;
    &lt;li&gt;Modula: Pascal语言对于系统应用编程来说太弱了。&lt;/li&gt;
    &lt;li&gt;Simula: Algol语言在仿真模拟方面不够好。&lt;/li&gt;
    &lt;li&gt;Smalltalk: Simula语言里并不是所有的东西都是对象。&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;Fortran: 汇编太底层了。&lt;/li&gt;
    &lt;li&gt;Cobol: Fortran语言不好用。&lt;/li&gt;
    &lt;li&gt;PL/1: Fortran语言缺少足够的数据类型。&lt;/li&gt;
    &lt;li&gt;Ada: 所有现存的编程语言都有缺失。&lt;/li&gt;
    &lt;li&gt;Basic: Fortran语言不好用。&lt;/li&gt;
    &lt;li&gt;APL: Fortran语言在数组操作上不好用。&lt;/li&gt;
    &lt;li&gt;J: APL语言需要自己的字符集。&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;C: 汇编太底层了。&lt;/li&gt;
    &lt;li&gt;C++: C语言太底层了。&lt;/li&gt;
    &lt;li&gt;Java: C++太笨重。微软在压迫我们。&lt;/li&gt;
    &lt;li&gt;C#: Java是Sun公司控制的。&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;Lisp: 用图灵机方式描述计算机计算太别扭。&lt;/li&gt;
    &lt;li&gt;Scheme: MacLisp语言太笨拙。&lt;/li&gt;
    &lt;li&gt;T: Scheme语言没有程序库。&lt;/li&gt;
    &lt;li&gt;Common Lisp: Lisp方言太多了。&lt;/li&gt;
    &lt;li&gt;Dylan: Scheme语言没有程序库，Lisp语法太疯狂。&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;Perl: Shell脚本/awk/sed都不像编程语言。&lt;/li&gt;
    &lt;li&gt;Python: Perl语言太让人受不了。&lt;/li&gt;
    &lt;li&gt;Ruby: Perl语言太笨拙，Lisp语法太疯狂。&lt;/li&gt;
    &lt;li&gt;Prolog: 编程不够逻辑。&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;js： java不适合新手&lt;/li&gt;
    &lt;li&gt;易语言:你们都不支持中文编程 &lt;/li&gt;
    &lt;li&gt;爱编：你们都不国际化&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;目前处于大整合阶段：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;界面使用统一跨平台语言：html+css+js&lt;/li&gt;
  &lt;li&gt;效率：开发效率，运行效率需要平衡&lt;/li&gt;
  &lt;li&gt;国际化： 更易用、高效的编程——提升开发效率，降低学习难度&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;语法流派&lt;/h3&gt;

&lt;p&gt;先说说语法，人类社会中存在大概三种下命令方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;领导说：“甲乙丙丁！”甲乙丙丁：“在！”领导：“你们去ooxx！”甲乙丙丁：“是！”&lt;/li&gt;
  &lt;li&gt;另一种是：领导说：我们要去ooxx，嗯，甲乙丙丁，你们去做这件事吧！&lt;/li&gt;
  &lt;li&gt;简化命令法：甲乙丙丁 去xxx&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;第一种是一般常见的编程语言，比如c，js。&lt;/li&gt;
  &lt;li&gt;第二种是链码等各种前置标识表达式或者成对标识语言会采用的方式。&lt;/li&gt;
  &lt;li&gt;第三种一般是用在脚本语言，好处是快速简洁，但程序一长，就很难懂。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种和第三种都是直抒式，第二种是抽象式。为什么会有这么些方式呢？&lt;/p&gt;

&lt;p&gt;第一种和第三种是： &lt;code&gt;2+3+0=5&lt;/code&gt;  （需要写2个+号）&lt;/p&gt;

&lt;p&gt;第二种是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    2
    3
+   0
-------
    5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好处：节省笔墨，语义化易懂。（只需要写一个+号，可见设计者明显是个有办法的懒人）&lt;/p&gt;

&lt;p&gt;前置标识表达式有很多种：比如链码，markdown，比如json，其实C和JS也算部分的前置表达，但其表达式内部都是直抒式的。&lt;/p&gt;

&lt;p&gt;网标码的成对语义化表达方式，太过浪费笔墨。&lt;/p&gt;

&lt;p&gt;另外几种特殊的编码，比如摩斯码、简符码等简化命令式，则很难懂。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;程序的共有特征&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;编程语言的构成要素&lt;/h3&gt;

&lt;p&gt;一套编程语言，无非是：&lt;strong&gt;表达的类型+操作（读、写、查），穷尽各种组合就是了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般而言，编程语言之间的不同，在于抽象方式各异：各个语言为了达成自己的主要目的，在着眼点上会极尽所能的抽象方式，提供该方面尽可能大的可操控能力，该方面的稳定性，该方面的可测试性。&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;         类型 |纵坐标：操作对象
              |
         与非 |
         数字 |
         字符 |
         内名 |
    横坐标____|______________________________________
    操作      |    读     查    写
       字符串 |
       数据流 |
           树 |
           表 |
         函数 |
         向量 |
         链串 |
         拓扑 |
         闭合 |
       连续统 |
     提示信息 |
     文件路径 |
       程序包 |
              |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;进一步细分：&lt;/p&gt;

&lt;p&gt;【类型】：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数字（整数、单数、复数、浮点数……进制，关联操作加减乘除可以看成是合并、删除、拆分等操作）&lt;/li&gt;
  &lt;li&gt;名-属性类（集、数组、数列、链串、清单、拓扑、散列表、列联表、对应表、字典、n维表、向量、序列……）&lt;/li&gt;
  &lt;li&gt;程序包级别（类、名位、包、系统……）&lt;/li&gt;
  &lt;li&gt;提示信息（提示、示警、出错仍继续、出错中止）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;【操作】：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;读（读法，列出所有，统计）&lt;/li&gt;
  &lt;li&gt;查[判断，查有没有，要哪个，在哪]&lt;/li&gt;
  &lt;li&gt;写[改变（类型/值/位置），新造，删除，合并，拆分]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;【怎么操作】：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;默认：按先后顺序操作&lt;/li&gt;
  &lt;li&gt;流程控制：条件控制&lt;/li&gt;
  &lt;li&gt;重复操作：宏
    &lt;ul&gt;
      &lt;li&gt;自动脚本&lt;/li&gt;
      &lt;li&gt;统筹法&lt;/li&gt;
      &lt;li&gt;框架&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;新设计语言可以参考神编和sibilant的构造经验：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;设定存在的类型，&lt;/li&gt;
  &lt;li&gt;批量判断输入输出类型是否正确，逐个判断还是批量判断？，&lt;/li&gt;
  &lt;li&gt;具体设定各个函数的功能，但不判断类型，只读入读出？。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-5&quot;&gt;编程语言常有的机制&lt;/h3&gt;

&lt;p&gt;命名：对每个操作和操作对象都命名，以方便调用。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;程序设计思路：抽象，化整为零&lt;/h3&gt;

&lt;p&gt;抽象化，自动化&lt;/p&gt;

&lt;p&gt;化整为零，简化问题解决方式&lt;/p&gt;

</description>
        <pubDate>Mon, 2014 May 05 00:00:00 +0800</pubDate>
        <link>http://jobinson.ga/%E6%8A%80%E6%9C%AF%E6%99%AE%E5%8F%8A/2014/05/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%A7%A3%E5%89%96/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E6%8A%80%E6%9C%AF%E6%99%AE%E5%8F%8A/2014/05/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%A7%A3%E5%89%96/</guid>
      </item>
    
      <item>
        <title>个人知识管理经验汇总</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;个人知识管理&lt;/h2&gt;

&lt;p&gt;目的：主要用于收集学习的资料，做笔记，想一些零碎的想法。&lt;/p&gt;

&lt;p&gt;两种主要用途：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;知识笔记：不断累加的，有些因为各种原因需要保密——还可能需要别人也参与修改，但因为有了git这种工具，使得维基不再是唯一的方式。换句话就是方便的持续集成！&lt;/li&gt;
  &lt;li&gt;个人日志：不需要修改的，有些隐私，需要保密权限的设定&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了最大化效率，需要做到：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;掌握一种富格式文本：因为文本最通用&lt;/li&gt;
  &lt;li&gt;理想学习生态链：版本管理——所见即所得编辑——发布——持续修订&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;利用版本管理来管理协作社区！&lt;/li&gt;
  &lt;li&gt;利用简化的格式，来专注内容&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;选用工具&lt;/h3&gt;

&lt;p&gt;下面列出我自己用过的各种个人知识工具总结：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;工具&lt;/th&gt;
      &lt;th&gt;优点&lt;/th&gt;
      &lt;th&gt;缺点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;word类&lt;/td&gt;
      &lt;td&gt;格式完美，批注方便&lt;/td&gt;
      &lt;td&gt;编辑软件不通用，编辑软件有点大，发布不方便&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;博客类&lt;/td&gt;
      &lt;td&gt;用过博客中国，搜狐，网易的&lt;/td&gt;
      &lt;td&gt;过分依赖特定服务器，定制性不够&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wordpress&lt;/td&gt;
      &lt;td&gt;定制能力好，网上到处可见其身影&lt;/td&gt;
      &lt;td&gt;自己管理服务器麻烦，之前自己建过类似的，后来懒得麻烦了就重回网易博客&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wiki类&lt;/td&gt;
      &lt;td&gt;可定制，内部索引完美&lt;/td&gt;
      &lt;td&gt;也是需要依赖服务器，不用服务器的tiddlywiki是打包到一个文件中，及其变态&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;笔记类网站&lt;/td&gt;
      &lt;td&gt;简单方便, 非常适合于做笔记&lt;/td&gt;
      &lt;td&gt;用了360doc好几年，还一直用网易的笔记，印象笔记用过一阵子放弃了，这类的缺点是依赖服务器，自主性不够，整理花费时间长（主要是操作需要等等服务器反馈，时间冗长）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;basket类&lt;/td&gt;
      &lt;td&gt;灵活，添加点子很方便，界面漂亮快速&lt;/td&gt;
      &lt;td&gt;导出太丑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;org-mode&lt;/td&gt;
      &lt;td&gt;用起来很爽，功能丰富&lt;/td&gt;
      &lt;td&gt;调教所需花费的时间太多&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;github+jekyll&lt;/td&gt;
      &lt;td&gt;方便版本管理，流畅的操作流程&lt;/td&gt;
      &lt;td&gt;jekyll本身转码器不甚满意，不过已经可以算很满意了。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;静态空间+版本管理+生成工具&lt;/td&gt;
      &lt;td&gt;定制能力逆天，而且可以累积的，有空就改改，最接近完美的&lt;/td&gt;
      &lt;td&gt;可以用各种生成工具，从pandoc，orgmode到makefile任意&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中，用得觉得爽的是：360doc，basket，orgmode，markdown+jekyll。
最后三种，可以做到本地笔记和发布的笔记同步，从而不用同时维护两种，彻底打通整个链条。
比如本文，本地和远程原来就是两个版本，有了后面工具后，就合并为一个了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;知识笔记的需求&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;容易转为其他格式的：也就是语法要通用性好，或者说各种格式转换方便，尤其是要有转出为html能力：有pandoc这个转换利器，html-org，html-markdown，markdown-html的转换不是啥问题。但org只能在orgmode里转html。&lt;/li&gt;
  &lt;li&gt;编辑方便的：
    &lt;ul&gt;
      &lt;li&gt;如果没有所见即所得编辑器，则语法要简练。&lt;/li&gt;
      &lt;li&gt;编辑器要好用。——最好有所见即所得的编辑器。但所见即所得编辑器只可以编辑看得见的，看不见的编辑不了，掌控不到全局。&lt;/li&gt;
      &lt;li&gt;html配合zencoding后，写起来爽的一塌糊涂。相比而言，markdown，orgmode都还要略为逊色。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;普通阅读干扰少的：html渲染后虽然不错，但如果不渲染，其符号太多，阅读干扰大，尤其是一些手持设备还普遍对所见即所得编辑器有巨大的问题的时候，在这些设备上编辑会很麻烦。&lt;/li&gt;
  &lt;li&gt;格式要求：
    &lt;ul&gt;
      &lt;li&gt;有方便的大纲显示：学习和创作中，知识的系统性很重要。word有大纲视图，易码肆配合speedbar可以搞定，内部也可以用outline来搞大纲视图。&lt;/li&gt;
      &lt;li&gt;内容与样式分离, 写作专注于内容，长啥样后期控制，或者阅读者控制。&lt;/li&gt;
      &lt;li&gt;标题&lt;/li&gt;
      &lt;li&gt;段落&lt;/li&gt;
      &lt;li&gt;具备2种以上复加强调功能, 包括粗体, 颜色。——html可搞定，orgmode可以通过特殊设置，markdown可通过嵌入html代码解决。&lt;/li&gt;
      &lt;li&gt;表格&lt;/li&gt;
      &lt;li&gt;列表: 有序 和 无序&lt;/li&gt;
      &lt;li&gt;代码相关:
        &lt;ul&gt;
          &lt;li&gt;原样输入：orgmode在插入自身的特有代码时需要注意一下。markdown由于利用缩进，可以做到表述自身代码很容易。&lt;/li&gt;
          &lt;li&gt;原样输出&lt;/li&gt;
          &lt;li&gt;代码高亮&lt;/li&gt;
          &lt;li&gt;最好有 元文档能力： 代码可以运行获得结果，也可以以源码形式保留。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;发布：
    &lt;ul&gt;
      &lt;li&gt;可以转化为静态html用于网站发布&lt;/li&gt;
      &lt;li&gt;能自动生成目录功能。&lt;/li&gt;
      &lt;li&gt;页眉页脚与配色方案等可以独立于每篇文章作成模板。&lt;/li&gt;
      &lt;li&gt;本地与在线都能使用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;内容管理:
    &lt;ul&gt;
      &lt;li&gt;使用版本管理: 不会担心什么误操作把辛苦多年的积累给干掉.&lt;/li&gt;
      &lt;li&gt;版本管理工具最好是分布式的, 不依赖于服务器, 这样费用就低, 离线使用也方便。&lt;/li&gt;
      &lt;li&gt;可以通过版本管理工具进行多人协作。&lt;/li&gt;
      &lt;li&gt;可以通过查看代码改动来做文档批注工具。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 2014 Apr 29 22:53:21 +0800</pubDate>
        <link>http://jobinson.ga/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/2014/04/29/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E7%BB%8F%E9%AA%8C/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/2014/04/29/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E7%BB%8F%E9%AA%8C/</guid>
      </item>
    
      <item>
        <title>【公开课】软件是啥</title>
        <description>&lt;p&gt;注：因为场地的原因，目前没法给各位报名参加我的免费编程培训，就转到这里来开公开课，喜欢的拿去看，我会慢慢填坑，逐步把整个产业链的方方面面都涉及到，给大家当入门。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;古老而又新鲜&lt;/h2&gt;

&lt;p&gt;大概三千年前，周穆王时代，四川就已经有了偃师的木甲术，六百多年后，到了春秋时期，鲁班制造了机关人，而墨子则制造了最早的飞机，它们都是具备了一定的智能，但这种智能很难控，因为其利用了一种动物的能量和部分可控智能：老鼠！&lt;/p&gt;

&lt;p&gt;机器心脏藏着一只甚至多只老鼠，老鼠在机关人的心脏里活动，通过线牵动机器的四肢，使得机器能够动起来。&lt;/p&gt;

&lt;p&gt;这有点像我们平常所见到的木偶戏一样，只不过木偶是靠人控制，而机关人是靠里面老鼠的活动。&lt;/p&gt;

&lt;p&gt;之所以选择老鼠，是因为老鼠生命力很强，又很活跃，闲不住，能够给机关人提供一定的能量，并且使得机关人看起来像是活的。&lt;/p&gt;

&lt;p&gt;墨子和鲁班同时还根据老鼠的活动规律，设计了一套与之匹配的操控流程，比如听到猫声，老鼠就会瑟瑟发抖，比较安静，把这种行为设定为机关人停止活动——这也就是我们现在很熟悉的声控。&lt;/p&gt;

&lt;p&gt;这叫机关术，可以在游戏 轩辕剑外传枫之舞 里面玩到。其精妙程度后来成了精妙巧智的代名词：机关！经常在考古类电影里看到这些，一般是早就设计好一整套机器，然后等着人去触动，触动则整套机器运动起来。&lt;/p&gt;

&lt;p&gt;总结下，机关人和机关，这些都是最古老和精妙的程序，是融合“软硬”知识，综合生物、物理、材料等学科专业知识，设计制造出来的。&lt;/p&gt;

&lt;p&gt;当然，这种机关的缺点也很明显：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;能量不足，可持续性差：老鼠的生命活力是很有限的，整天跑去抓活老鼠也不是那么容易，养的话也颇费资材。不过这是时代局限，那个古老年代大家还没法利用石油和电力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另外一个缺陷就是设计难度过高：为了让小老鼠牵动大机械，需要非常精妙的安排，机关重重，这样的复杂度，也只有绝顶聪明的人才能做到，及其消耗脑力。人才培养的困难和优秀人才的匮乏，必然使得传承难度极大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后就是动物的可控性不足，使得机器的行为稳健性太差。老鼠毕竟是活生生的动物，有时难免暴走，机械此时的行为就很难预估了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过，即使有这些固有的缺陷，但这套技术却并没有完全失传：一部分被用来制造古代的生产和战争用的机械，比如纺织机和弩机；一部分被用来设置机关暗道，据说秦皇陵就是这样，真假不明；一部分则演变成日常的游戏：木偶戏。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;智能的核心：软件&lt;/h2&gt;

&lt;p&gt;在上面提到的机关人中，硬件就是：木头制造的各种部件，还有连接这些部件的各种线。另外就是驱动力：能量！比如动物能，电，汽油什么的。&lt;/p&gt;

&lt;p&gt;但有这堆木头、线和能量，组装起来的机械还是比较简单的，需要人去操控，才能发挥其巨大威力。&lt;/p&gt;

&lt;p&gt;就像汽车，如果不用人或者智能程序控制，汽车自己开着开着就会掉沟里去。&lt;/p&gt;

&lt;p&gt;人虽然全能，但人毕竟是肉体，会累，会情绪不稳，需要吃饭，需要休息，如果有那么一种东西，能够让机器自动而且还正确地运行，那多好啊！&lt;/p&gt;

&lt;p&gt;有！这东西有，古代人是设计一整套程序，然后靠某些条件去触发，而现代人则从简单的控制电路，到单片机，到智能芯片，到全能芯片，到超算……
控制方式越来越智能，运算能力越来越强大，可以实现的事情越来越多。&lt;/p&gt;

&lt;p&gt;从简单的在电脑上设计程序，让程序去控制机械，到模拟木偶戏，用电脑去演戏——说的就是在电脑上打游戏、看电影、上网灌水啊！&lt;/p&gt;

&lt;p&gt;啥？看电影打游戏上网灌水也是在控制机械？对的，没说错，不过你控制的是：显示器的每个非常小的像素点和网关的收发操作。这些你都没感觉到而已，因为程序会根据你打字和发送动作，自动帮你完成了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;计算机的历史：什么样才算计算机&lt;/h2&gt;

&lt;p&gt;只要有“寄存”功能，就是计算机！
只要能运算四则运算，就能运算所有数学问题，只不过是时间长短而已。&lt;/p&gt;

&lt;p&gt;算筹——》算盘——》珠算——》算尺——》电子计算机——》集成电路后的计算机——》联网时代的计算机（超算）&lt;/p&gt;

&lt;p&gt;算盘不简单，一点不比现代计算器弱！因为其有“暂记”功能。
是一个可以复杂计算的计算机！尤其是高阶的算盘。&lt;/p&gt;

&lt;p&gt;下面是最常见的9档算盘&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;| 1 | 1 | 1 | 1 | 1 || 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 || 1 | 1 | 1 | 1 |
|   |   |   |   |   ||   |   |   |   |
| --| --| --| --| --|| --| --| --| --|
|   |   |   |   |   ||   |   |   |   |
| 1 | 1 | 1 | 1 | 1 || 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 || 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 || 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 || 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 || 1 | 1 | 1 | 1 |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;算盘形状：简单的日常所见的
超长算盘：一般只在电影里看到
多维算盘：至少两个算盘，交叉成坐标
圆算盘：
八卦形状算盘：24档&lt;/p&gt;

&lt;p&gt;计算尺
手工：发展到珠算+计算尺 已经算是极限&lt;/p&gt;

&lt;p&gt;机械：发展到机械计算器已经开始超越手工
帕斯卡加法器：第一台机械计算器，10进制，加减法   机械钟表（60进制）
1674年，莱布尼茨 改进机械计算器（四则运算） 从八卦中获得灵感，提出以二进制设计计算器，系统提出了二进制运算法则&lt;/p&gt;

&lt;p&gt;提花编织机：手工的提花——》简单编程的提花（先打好孔）
1725年，布乔：纸带，通过编织孔控制提花机的提花动作——这种方法，标准化考试的时候那些答题卡还在用。
1805年，杰卡德：自动提花编织机，同时操控1200个编织针&lt;/p&gt;

&lt;p&gt;提花技术至今仍然非常重要，比如在印刷多层电路板上
1822年 巴贝奇： 差分机 1834年，分析机设想
分析机：现代计算机的模型
+ 存贮库：每个齿轮存贮10个数，齿轮阵列存贮1000个50位数
+ 运算室：
+ 控制部分：控制运算顺序
构思了 送入和取出数据的机构，
存贮室和运算室间运算数据的部件
其伙伴：拜伦独生女 阿达 编制了一批函数程序&lt;/p&gt;

&lt;p&gt;1888年 霍列瑞斯 （Hollerith）从杰卡德的自动提花机获得灵感，为了人口统计数据处理，制造 自动制表机：二进制，多个统计项目，根据打孔情况进行自动统计。&lt;/p&gt;

&lt;p&gt;1944年 艾肯，从巴贝奇和阿达那里获得灵感，用机电方式替代巴贝奇的机械方式。领衔造出马克一号，3000继电器，通过电磁铁控制开关动作。
霍波（Hopper，cobol设计者）编写程序
臭虫（bug）：在马克一号里发现一只飞蛾卡住计算机。——硬件故障&lt;/p&gt;

&lt;p&gt;1883年，爱迪生效应（电子管原理）
1895年，弗莱明为了无线电讯号检波问题，根据爱迪生效应，发明 热离子阀（第一只电子管，真空二极管，把交流电整流成直流电）
1906年，福雷斯特为了提高二极管检波灵敏度，发明真空三极管（加入栅栏式金属网，栅极可以微小电流控制阴极和屏极——屏极可获得较大电流，也就是放大作用）
1912年，福雷斯特，在硅谷利用真空三极管制作了 放大器&lt;/p&gt;

&lt;p&gt;电子管：无线电装置中用于检波，整流，放大，振荡元件&lt;/p&gt;

&lt;p&gt;电子管的饱和状态：电流从阴极到屏极完全导通
电子管的截至状态：电流从阴极到屏极没有电流通过
两种状况用栅极控制，比艾肯继电器快10000倍&lt;/p&gt;

&lt;p&gt;1939年，阿坦那索夫 完成电子计算机设想，1942年装配出 ABC计算机，第一台电子计算机
1943年 英国巨人密码机（2015年才能解密 Colossus） 图灵
1943年，莫尔学院开始设计制造电子计算机，1946年2月14日，第一台实用的电子计算机（大众情人ENIAC）诞生：电子数学积分和计算机。运算速度在马克一号1000倍以上。
弱点：程序和计算分离，程序指令倍放在机器的外部电路里
1945年，离散变量自动电子计算机（EDVAC）101页报告（诺伊曼机：计算机的五大部件，二进制替代十进制简化电路设计，程序也当作数据存入机器内部）&lt;/p&gt;

&lt;p&gt;1950年，图灵 ACE&lt;/p&gt;

&lt;p&gt;1951年 兰德公司的通用计算机（UNIVAC）
1953年，小沃森 全用途的科学计算机，IBM701：放弃穿孔卡，改用 真空管逻辑电路，磁芯存储器，磁带机 &lt;/p&gt;

&lt;p&gt;1947年，贝尔实验室，半导体放大器（点接触型晶体管）
1948年，结型晶体管
1954年，贝尔实验室，第一台晶体管计算机（TRADIC）
1957年，仙童公司，半导体平面处理技术（氧化，拍照，刻蚀，扩散）
1958年，德州仪器公司，锗片，用热焊法连接导线，集成电路（晶体管很小，而其中起作用的部分更小，大部分被支架管壳占用了）
1959年，仙童公司，硅片，蒸发沉积金属法替代热焊法
1961年，德州仪器公司，第一台集成电路计算机
1963年，巨型机CDC6000：并行（一中央处理器，10外围处理器）
1964年，IBM360（360度=全方位）兼容性
1969年，通用 小型机Nova
英特尔公司 存储芯片3101（双极性集成电路）
1970年，英特尔公司，1103（动态随机存储器DRAM）
1971年，微处理器（中央处理器微缩在一块集成电路上）
1972年，图形用户界面
1974年，牛郎星：第一台用微处理器的微型计算机
1975年，微软BASIC&lt;/p&gt;

&lt;p&gt;密码机
科郝 秘密写作机
德国二战 谜 密码机（Enigma）：加密
1939年，英国罗宾逊&lt;/p&gt;

&lt;p&gt;打孔机的优势：
+ 打孔机是2进制，而算盘是5进制或者说是简化了的10进制，二进制是抽象度更高更纯粹机械上可更容易实现的方法
+ 打孔机记忆能力更强：打在纸上，不会被人推倒桌子算子就乱
+ 运行更稳健：运行速度有保证，并且这种运行效率可以轻易复制（培养一个珠算高手需要耗费的资源和时间相对来说太长）&lt;/p&gt;

&lt;p&gt;问题：
如何用简单的四则运算算高阶数学？或者如何让高阶数学变为简单的四则运算？
在建国初期，面对复杂的数学，是用算法把计算量分解，最后汇总。&lt;/p&gt;

&lt;p&gt;第一台电子数字计算机 ENIAC
加法器 大约400个电子管
两个加法器可以完成乘法运算&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;软件可以干啥？&lt;/h2&gt;

&lt;p&gt;从上面我们知道，软件就是帮人更灵活控制各种机器的，从小到显示器的像素点，到大型机械。&lt;/p&gt;

&lt;p&gt;那么，我们现在还有必要逐个去细致控制每个像素点么？现在已经几乎不用这样麻烦了。&lt;/p&gt;

&lt;p&gt;现在控制整个屏幕的像素点，简单的只需要一句话就可以了。&lt;/p&gt;

&lt;p&gt;机械控制？现在也在大发展，有些领域已经不用再对机械的每一步进行人工设计了，比如目前的热门话题3d打印，可以做到在电脑上做设计图，不需设计生产流程，电脑自动调用设备进行堆叠浇筑成型。&lt;/p&gt;

&lt;p&gt;当然，仅仅控制机器还是不够的，田野的田用机器可以控制灌水和停水，但没法知道什么时候需要水，此时，需要添加监控装置，有了装置还不够，还需要能够自动发短信提醒。&lt;/p&gt;

&lt;p&gt;最终成品可见我之前发过的文章：用通用的智能控制芯片（比如arduino），外加一个通信模块（比如：gsm），再加几段代码，就完成了这个设备的简单自动化。&lt;a href=&quot;https://github.com/skorokithakis/arduino-irrigation&quot;&gt;完整代码在此&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意：不要被代码吓到了，后面会说到这些代码的规律。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;密码和代码&lt;/h2&gt;

&lt;p&gt;我发的链接里那段代码，大家看了估计会一片模糊，甚至会被吓退，但那仅仅是因为陌生，其实，代码并没有那么复杂。&lt;/p&gt;

&lt;p&gt;我们日常经常就经常接触，比如玩游戏的时候，会喊土豆土豆，我是地瓜，这里的“土豆”代表的是友好的同盟一方，而地瓜则代表着自己的身份，这就是最简单的代码。&lt;/p&gt;

&lt;p&gt;代码，就是用来代替某样东西的码表。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;地瓜 = 我 = 操作者
土豆 = 友好的盟友一方 =  被操作方
呼叫 = 查询
呼叫完毕等待接收状态 = 服务器伺服状态
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这实际上就是一道简单的人肉程序，代表两个人——服务器间的简单沟通。几乎所有的计算机程序都可以还原成如此简单的模式，只不过目前用的是各种大家还陌生的代号而已。下面我会说到这些代号的掌握方法。一点也不用被吓倒。&lt;/p&gt;

&lt;p&gt;这么简单的人肉程序，当然破解起来很容易，战争的发展，促使人们发明越来越复杂的密码，直到超出人脑所能推测的范围。——计算机也就是为了这种加密，解密需要发展出来。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;代码的本质&lt;/h2&gt;

&lt;p&gt;西游记中，孙悟空头上有个紧箍圈，唐僧只要一念紧箍咒，猴子就会头疼欲裂，痛不欲生。&lt;/p&gt;

&lt;p&gt;这其实和我们前面说到的机关是很像的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;被作用者 &amp;lt;—— 机关 &amp;lt;—— 触发机会 &amp;lt;—— 触发行为 &amp;lt;—— 触发者&lt;/li&gt;
  &lt;li&gt;孙悟空的头 &amp;lt;—— 紧箍圈功能启动 &amp;lt;—— 禁锢圈解码器 &amp;lt;—— 紧箍咒 &amp;lt;—— 唐僧&lt;/li&gt;
  &lt;li&gt;电脑的各种设备 &amp;lt;—— 电脑功能 &amp;lt;—— 电脑解码器 &amp;lt;—— 代码 &amp;lt;—— 我们&lt;/li&gt;
  &lt;li&gt;我们希望的地方 &amp;lt;—— 强大的神明 &amp;lt;—— 解码器（靠焚毁才能解码） &amp;lt;—— 符箓 &amp;lt;—— 我们求的某些天师&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这其中，唐僧念的紧箍咒就是我们这里要说到的代码，禁锢圈解码器就是电脑。&lt;/p&gt;

&lt;p&gt;好吧，我们烧香拜佛烧的符咒，本身也是一种代码，不过其作用方式和我们电脑有点不同。&lt;/p&gt;

&lt;p&gt;这可见，代码不仅仅是写在电脑上的，也可以是用嘴说的——声控！其实还可以是看的——手势隔空操作，甚至可以是想的。&lt;/p&gt;

&lt;p&gt;大概是2012年吧，有个身体瘫痪如霍金的程序员去世，他用的是摩斯码，用摩斯码来改gnome的界面，有人调戏说是累死的。&lt;/p&gt;

&lt;p&gt;就目前来说吧，声控和手势隔空操作，或者是意念还是触控操作，对于写代码来说，还是太简单原始的。目前代码最高效的生产环境仍然是电脑+键盘。&lt;/p&gt;

&lt;p&gt;所用代码的便捷性和实用性是很重要的，或许有的人眼睛不行，那么对他而言，最好就是编码语言就是不用眼睛最好，就像念咒语一样。&lt;/p&gt;

&lt;p&gt;选用什么语言呢？其实是每个人各异的，比如刚刚说到的累死的程序员，他除了摩斯码，别的选择对他来说都是太遥远的事。&lt;/p&gt;

&lt;p&gt;不过我们有手有脚的，不能和他比，如果我们选用的东西不顺手，也是可以自己改造，除非遇到不可抗力。&lt;/p&gt;

&lt;p&gt;什么叫不可抗力呢？就是客户需求！比如我们很流行的浏览器ie6，多么老迈，但因为用的人很多，而我们写程序就是为了给这些人用的，于是，我们不得不捏着鼻子，去屈就这些乱七八糟的东西。&lt;/p&gt;

&lt;p&gt;楼上有人好奇会具体教什么语言，应该说是会涉及四种类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;内容描述性语言：也叫格式，平时用到的会有好多种，有文本的，有多媒体的，甚至有流程描述的。&lt;/li&gt;
  &lt;li&gt;外观控制语言：也叫样式，这个因为事实标准化了，可以只有一种&lt;/li&gt;
  &lt;li&gt;转换的语言：这是为了方便而使用的。搞编程的有好几个对应的名词：宏，脚本，正则……这里统一叫 自动化 吧&lt;/li&gt;
  &lt;li&gt;交互控制语言：这个分两种情况，一种是顺手的工具，一种是通用的工具，看个人倾向。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;一段简单的代码&lt;/h2&gt;

&lt;h2 id=&quot;section-7&quot;&gt;软件用什么制造？&lt;/h2&gt;

&lt;p&gt;接下来说说代码是怎么制造的，先看看一个图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/images/软件是啥/多屏编程.png&quot; alt=&quot;多屏编程.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有点复杂是吧？其实，编程的软件可以简单，也可以复杂。有个比较简单的方法是使用记事本，没错，就是你windows开始菜单附件里那个记事本。&lt;/p&gt;

&lt;p&gt;但这还不是最简单的，最简单的命令行模式下的vi和nano。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/images/软件是啥/nano.png&quot; alt=&quot;nano.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从工具的简单，说明一件事：编程并不是复杂的事情，因此，我们没必要被吓到！&lt;/p&gt;

&lt;p&gt;从实际使用上，nano这个更简单的工具，使用起来反而比记事本方便快速。——我就用了好长时间nano。&lt;/p&gt;

&lt;p&gt;但nano等简单工具明显是不方便的，可以说，编程会有三种模式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;命令行下最简单模式：这是一种返璞归真，也是一种无奈的选择，因为有些设备没有图形界面，只能用这种简单的方式控制；另外就是远程管理服务器，为了节省带宽，只能用这种方式。&lt;/li&gt;
  &lt;li&gt;可扩展编辑器：这类的代表是易码肆（emacs）和vim，特点是快速，功能扩展方便，有很多现成的好用工具。&lt;/li&gt;
  &lt;li&gt;巨型编程套件，也就是程序员说的集成开发环境（IDE），这类的典型代表是通用型的VisualStudio，特定领域型的AdobeFlash等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么一个起码的编程生产线需要什么要素呢？&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;软件生产线需要的要素&lt;/h2&gt;

&lt;p&gt;如果觉得说的太慢，可以跳入下一步：
软件环境
由于windows系统本身使用的是 &lt;code&gt;gb18032&lt;/code&gt; 或者其他两个 &lt;code&gt;gbk&lt;/code&gt; &lt;code&gt;gb2312&lt;/code&gt; ，为了减少出错，统一换用 &lt;code&gt;utf-8&lt;/code&gt; 。——我可以说这几套逐个穷尽编码设计严重缺脑么？建议编写新华字典的去把那些当年设计这套方案的砖家放猪圈里喂养几天，然后可以送上案板。&lt;/p&gt;

</description>
        <pubDate>Mon, 2014 Apr 28 21:18:01 +0800</pubDate>
        <link>http://jobinson.ga/%E6%8A%80%E6%9C%AF%E6%99%AE%E5%8F%8A/2014/04/28/%E8%BD%AF%E4%BB%B6%E6%98%AF%E5%95%A5/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E6%8A%80%E6%9C%AF%E6%99%AE%E5%8F%8A/2014/04/28/%E8%BD%AF%E4%BB%B6%E6%98%AF%E5%95%A5/</guid>
      </item>
    
  </channel>
</rss>
