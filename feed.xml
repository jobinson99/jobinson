<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>黑传说</title>
    <description>乌抵天明</description>
    <link>http://jobinson.ga/</link>
    <atom:link href="http://jobinson.ga/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>我坎坷的技术之路</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;我的基础&lt;/h2&gt;

&lt;p&gt;首先，我是因为色弱被迫放弃理科的，物理化学生物等都学得是很不错的，我在理科上是很有基础的。记得初三我还利用此电磁方向差异，设计了一个永动机！（当时没考虑过 原动力、损耗、逆变所需能量阈值）&lt;/p&gt;

&lt;p&gt;其次，在大学寒假期间，我几乎把我嫂子的所有编程方面的书都翻了一遍，所以还是有基础的。&lt;/p&gt;

&lt;p&gt;再次，大学时就用frontpage，dreamweaver做过静态网站几个。大学时用vfp做过一个简陋的拨号程序。&lt;/p&gt;

&lt;p&gt;再次，大学毕业后，可以说不间断接触到网络相关技术。&lt;/p&gt;

&lt;p&gt;最后，在千寻之后，我想靠自己独立开始一项事业，于是，开始了漫长的转型：从产品设计、营销、管理、运营转型为全能（也就是多了一项技能：技术开发）。——————————————原因在另外一文说过。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;转型路：主要的技术轨迹&lt;/h2&gt;

&lt;h3 id=&quot;linux&quot;&gt;linux之路&lt;/h3&gt;

&lt;p&gt;一开始是使用ubuntu，开启了我对开源领域的了解，恰好和我先前秉持的理念非常契合。 &lt;/p&gt;

&lt;h3 id=&quot;pega&quot;&gt;pega的印象&lt;/h3&gt;

&lt;p&gt;在千寻的时候，刚好了解到一个系统pega，可以快速编程。让我看到快速编程的潜力。&lt;/p&gt;

&lt;h3 id=&quot;cms&quot;&gt;选cms来建网站&lt;/h3&gt;

&lt;p&gt;先是选cms来快速搭建网站，发现了很多优秀的东西，但发现离满足我需求还非常远。这一步是2008-2010年初，感谢在一个&lt;a href=&quot;http://www.ronsung.com&quot;&gt;写动态密码，内网监控，省墨打印&lt;/a&gt;朋友的指点提示下，我开始想到自己更多编程实现。&lt;/p&gt;

&lt;h3 id=&quot;python&quot;&gt;转入python&lt;/h3&gt;

&lt;p&gt;转入了python，选了需要更多编程技术的 web2py turbogears，web2py的第一版中文版就是我翻译的。但是，发现python处于升级换代的混乱期，使我意识到一个问题：标准要稳定，才好做扩展，后来的发展，应该建构在稳定基础上。另外一个就是我感觉对编程语言缺乏足够全面的掌握，使得我非常被动。&lt;/p&gt;

&lt;p&gt;这个时候，了解了数据库兼容层，对数据库有了全新的认识，翻译了 wwwsqldesigner，重写了其sqlarchemy模块。&lt;/p&gt;

&lt;h3 id=&quot;lisp&quot;&gt;转入lisp全面学习+全面理工科化&lt;/h3&gt;

&lt;p&gt;选了一个设计非常全面，且标准稳定的 commonlisp，这是一条漫漫的路，从2010年底到2014年，我一直都在里面徘徊，中间因为自己的一些私人问题，导致学习效率极其低下。由于资料过少，自己甚至翻译了所有的内建 内名。同时也对编程的方方面面技术，有了更全面的了解和深刻掌握。&lt;/p&gt;

&lt;p&gt;另外，也想到以此为基础，设计一套复合自己需求的语言：当时叫由码（international lisp = il ，发音刚好是 由），现在叫爱编（international programing language）&lt;/p&gt;

&lt;p&gt;这个阶段，个人也全面回归理工科化&lt;/p&gt;

&lt;p&gt;对 光，热，阵列，智能操控等有了全新的掌握。&lt;/p&gt;

&lt;h3 id=&quot;js&quot;&gt;使用js&lt;/h3&gt;

&lt;p&gt;使用js的时间很长，2012年到2014年还一直利用jquerymobile 和appframework做app应用，但都比较浅层。&lt;/p&gt;

&lt;p&gt;2014年初，在又一次研究了神码后，发现其很有意思，可以运行在浏览器上，可以运行在 lisp上……实际上，如果普及后，估计可以独立出一个编译器。所以，问题在于快速学习和普及！！！！&lt;/p&gt;

&lt;p&gt;另外，在心灰意冷中，感觉需要找点存在感，于是开始网上教小朋友编程，发现了很多制约编程学习和普及的问题，比如语言（英语不过关），设备（需要每人配一电脑），配置（需要复杂的编程环境配置，对新手来说，很可能这一步就把自己搞残废了），应用（大部分人想开网店而不知道可能有更多的应用）……——————————————另外文章里提过。&lt;/p&gt;

&lt;p&gt;在当时的阶段，是根本无法做到有效的、低门槛的教学。&lt;/p&gt;

&lt;p&gt;另外，由于对js的接触日益多了起来，于是，痛下决心，决定全面学习javascript，并至少先在其上实现一个可用的 爱编解析器，这样可以不用过多复杂配置，直观见效，方便学习使用。&lt;/p&gt;

&lt;p&gt;也是在这个时候，我正式把我的博客从原先的托管，转为利用github来建。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;打通任督二脉后……&lt;/h3&gt;

&lt;p&gt;拭目以待！&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;个人从技术上的伸手党，追随者，变成了生产者。&lt;/p&gt;

&lt;p&gt;其实，要不是被人严重干扰，至少可以早三年完成转型！！！&lt;/p&gt;

</description>
        <pubDate>Mon, 2015 Feb 09 10:10:57 +0800</pubDate>
        <link>http://jobinson.ga/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/2015/02/09/%E6%88%91%E5%9D%8E%E5%9D%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/2015/02/09/%E6%88%91%E5%9D%8E%E5%9D%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%B7%AF/</guid>
      </item>
    
      <item>
        <title>对张尧学透明计算架构的理解</title>
        <description>&lt;p&gt;&lt;strong&gt;说明一：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;长文可能很多人看不下去，先说结论：&lt;/p&gt;

&lt;p&gt;张所提出并实现的透明计算，确实是世界独创的，至今仍然如此，获奖实至名归。&lt;/p&gt;

&lt;p&gt;就其所公布的信息，是自己&lt;strong&gt;实现了两套网络协议，扩展了底层，架空了操作系统&lt;/strong&gt;，使得操作系统变得无足轻重。&lt;/p&gt;

&lt;p&gt;有点类似超算的操作系统，不过超算是本地的，他这套扩展到网络了。&lt;/p&gt;

&lt;p&gt;形象比喻下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在一片树林里扎篱笆，原来是在树枝上扎——普通分布式计算，一般僵尸网络&lt;/li&gt;
  &lt;li&gt;后来有人在树干上扎，——云计算&lt;/li&gt;
  &lt;li&gt;张的团队则是跑到根部扎——透明计算，超算&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;第一部分 收集到的透明计算信息&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;自然科学一等奖得主中南大学校长张尧学简历&lt;/h3&gt;

&lt;p&gt;1956年1月生，湖南常德澧县人，1982年本科毕业于陕西西北电讯工程学院(现陕西西安电子科技大学)，1987年4月加入中国共产党，获日本东北大学博士学位。教授，博士生导师，中南大学校长，中国工程院院士，中国作家协会会员，国务院学位委员会委员，国务院信息化咨询委员会委员，计算机学会普适计算专委会委员，&lt;strong&gt;解放军总装备部军用计算机及软件技术专业组专家&lt;/strong&gt;，《International Journal of Wireless and Mobile Computing》《Journal of Autonomic and Trusted Computing》《Chinese Journal of Electronics》等国内外学术期刊的编委。曾任教育部高等教育司司长、学位管理与研究生司司长、国务院学位委员会办公室主任、985工程办公室主任、211工程建设办公室主任等学术和行政职务。著有《又见木兰》、《水随天去》等管理类散文集。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1976年10月至1978年10月，在湖南澧县余家台水电站工作，测绘员;&lt;/li&gt;
  &lt;li&gt;1978年10月至1982年07月，在陕西西安电子科技大学(原陕西西北电讯工程学院)电子工程系学习，获学士学位;&lt;/li&gt;
  &lt;li&gt;1982年07月至1983年02月，在西安电子科技大学出国研究生预备班学习;&lt;/li&gt;
  &lt;li&gt;1983年02月至1983年09月，在大连外国语学院日语培训班学习;&lt;/li&gt;
  &lt;li&gt;1983年09月至1990年03月，在日本东北大学硕士生、博士生并获硕士、博士学位;&lt;/li&gt;
  &lt;li&gt;1990年03月至1995年07月，在清华大学计算机系任教师、副教授、教授，教研组副主任;1994年6月任清华大学计算机系副系主任;1995年2月评定为博士研究生导师;&lt;/li&gt;
  &lt;li&gt;1995年07月至1995年10月，在美国麻省理工学院作访问教授;&lt;/li&gt;
  &lt;li&gt;1995年10月至1997年11月，电子部计算机司副司长兼全国电子信息系统推广办公室副主任(挂职);&lt;/li&gt;
  &lt;li&gt;1997年11月至1999年06月，清华大学计算机系教授、博士生导师;&lt;/li&gt;
  &lt;li&gt;1999年06月至2000年06月，教育部科学技术司副司长(主持工作);&lt;/li&gt;
  &lt;li&gt;2000年06月至2001年05月，教育部科学技术司司长;&lt;/li&gt;
  &lt;li&gt;2001年05月至2009年06月，教育部高等教育司司长(其中，2001年11月至2006年5月兼任中央广播电视大学校长;2004年3月至2005年1月参加中央党校一年制中青年干部培训班;2007年5月至2008年9月任北京奥组委挂职总体策划部副部长;2007年当选为中国工程院院士);&lt;/li&gt;
  &lt;li&gt;2009年06月至2011年10月，国务院学位委员会办公室主任、教育部学位管理与研究生教育司司长;&lt;/li&gt;
  &lt;li&gt;2011年11月至今，中南大学校长(副部长级)。&lt;/li&gt;
  &lt;li&gt;2011年10月21日，中共中南大学委员会委员、常委。&lt;/li&gt;
  &lt;li&gt;2011年11月1日，中南大学校长。&lt;/li&gt;
  &lt;li&gt;2015年1月9日，清华大学教授、中南大学校长张尧学院士率队完成的“网络计算的模式及基础理论研究”项目荣获2014年度国家自然科学奖一等奖。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;成就：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1995年主持研制成功国内首台 &lt;strong&gt;网络路由器&lt;/strong&gt;，并推动了这一事关国家安全和信息产业核心产品的产业化。率先在国际上开展主动服务和透明计算领域的研究，提出了在&lt;strong&gt;时空上扩展&lt;/strong&gt;冯诺依曼结构、把信息存储、运算和管理分开的透明计算理论与方法，并研究成功了基于该理论的 &lt;strong&gt;内核分布式操作系统&lt;/strong&gt; 和&lt;strong&gt;无操作系统的透明计算终端&lt;/strong&gt;，广泛用于中国军事、商务、教育和管理等领域，受到了国内外学术界的重视，被国外同行认为是“先于云计算，并包含了云计算”的原创性学术成果，并正向服务手机、云手机等移动互联网、家庭网等领域扩展。&lt;/p&gt;

&lt;p&gt;在网络基础理论方面提出了被美国同行称为“Zhang’s method”的交互式协议综合法，推动了网络基础理论的发展和进步。以第一获奖人获国家技术发明二等奖一项、国家科技进步二等奖两项；获IEEE AINA07最佳论文奖，何梁何利科技进步奖，美国IET教育基金会教育领先奖，以及亚洲开放大学联合会功勋服务奖等奖项。撰写中英文专著和教材8部，其中《计算机操作系统教程》已销售100余万册，成为国内计算机领域的主要教材之一。&lt;/p&gt;

&lt;p&gt;主持完成了多项国家级科研、国际合作及重大产业化项目。以第一完成人获国家技术发明二等奖1项、国家科技进步二等奖2项、省部级奖励5项。&lt;/p&gt;

&lt;p&gt;主要的研究方向是透明计算和主动服务。透明计算主要是研究如何解决用户通过网络上的同一终端平台使用不同操作系统和相关应用，以及在不同终端平台上使用同一操作系统和相关应用。主动服务是按照用户需求，通过计算机对现有服务进行演化，从而提供尽可能满足用户需求的网络服务的一种计算方法。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;清华大学的通稿&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://news.tsinghua.edu.cn/publish/news/4205/2015/20150112091258538502525/20150112091258538502525_.html&quot;&gt;透明计算引领“下一个计算时代”&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;——“网络计算的模式及基础理论研究”获国家自然科学一等奖&lt;/p&gt;

&lt;p&gt;该研究项目是在张尧学院士带领下，由清华大学计算机系教师周悦芝、林闯、任丰原和中南大学教师王国军共同完成的。该研究在国际上率先提出透明计算的新概念，突破了冯•诺依曼结构的局限，成功研制出了具有独立知识产权的超级操作系统和一系列具有原创性与系统性的重大创新成果，对促进我国计算机及相关产业转型升级发展具有重要意义。&lt;/p&gt;

&lt;p&gt;张尧学院士带领的科研团队自1991年开始，历经20余年的潜心研究，将计算机体系结构与计算模式的创新同国家经济社会的重大需求结合，在国际上首次提出了把一个自治网络虚拟成单机的新计算模式——透明计算。该计算模式把单机总线扩展到网络带宽，从而实现一个自治域内所有计算机的存储器和CPU的统一虚拟管理，以实现在自治域网络环境下的计算、存储和管理分离，并创造性地提出了“流式计算”方法，把操作系统和应用程序转变为能让用户随时随地获取的服务，由服务器统一管理与维护，如同水、电等资源一样，在用户需要时源源不断地提供，用户使用完毕后自动流走，从而始终保持用户终端的小巧轻便和操作简易，同时可以获得大规模数据服务。&lt;/p&gt;

&lt;p&gt;研究团队还根据透明计算原理，成功研制出了具有独立知识产权的，运行在各种操作系统之下、主板之上的超级操作系统（Meta OS），使用户可以根据需要，通过近乎裸机的小终端设备获取不同操作系统平台的各类服务，从而大大降低了对用户终端的要求，解决了各种操作系统安全漏洞及多操作系统的兼容与跨平台问题。该团队还提出了高可靠网络协议和开发方法，研制了多操作系统远程加载协议（MRBP）和网络服务访问协议（NSAP），保证可靠的跨平台操作，将网络互连平台由较高的网络层下降到计算机芯片和操作系统间的接口层，从而打开了被国外厂商控制的芯片与操作系统之间的“黑匣子”，并可以通过在接口层设计保护程序，防止上层软件系统受到攻击和安全漏洞威胁，解决信息网络的安全问题。&lt;/p&gt;

&lt;p&gt;透明计算这一成果在国际上开辟了一个新的研究领域和发展方向，为网络计算提供了全新的模式和理论基础，得到了学术界的高度评价，认为“透明计算取代已经控制了计算机系统思想和实践至少60年之久的传统冯•诺依曼结构”。Intel公司总裁Renee James也认为：“透明计算提供无缝的、跨平台的用户体验，代表了下一个计算时代。”国内外有40多所大学和科研机构正进行相关跟踪研究，200多家国际主要技术媒体对此进行了长篇报道和评论，不少评论认为“这将是首个由中国推动的计算技术”。&lt;/p&gt;

&lt;p&gt;目前，该项目已研制成功多种产品，应用于国防、教育、互联网等领域，未来将进一步推动透明计算与大数据、移动互联网相结合，对国家社会经济发展和网络信息安全提供支撑，推动相关产业升级换代，形成新的学科领域和研究方向。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;申请获奖用的论文&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Yaoxue Zhang and Yuezhi Zhou. Transparent Computing: A New Paradigm for Pervasive Computing, LNCS 4159, 2006 年第1 卷1-11 页.&lt;/li&gt;
  &lt;li&gt;Yaoxue Zhang and Yuezhi Zhou. 4VP+: A Novel Meta OS Approach for Streaming Programs in Ubiquitous Computing, in Proc. of the IEEE 21st International Conference on Advanced Information Networking and Applications (AINA 2007), 2007 年第1 卷394-403 页.&lt;/li&gt;
  &lt;li&gt;Yaoxue Zhang, K. Takahashi, N. Shiratori, and S. Noguchi. An Interactive Protocol Synthesis Algorithm Using a Global State Transition Graph, IEEE Transactions on Software Engineering, 1988 年14(3)卷 394-404 页.&lt;/li&gt;
  &lt;li&gt;Yaoxue Zhang, Hua Chen. A knowledge-based dynamic job-scheduling in low-volume/high-variety manufacturing, Artificial Intelligence in Engineering (UK), 1999 年13(3)卷 241-250 页.&lt;/li&gt;
  &lt;li&gt;林 闯 . 计算机网络和计算机系统的性能评价, 清华大学出版社， ISBN:7-302-04267-5, 2001 年卷109-129 页.&lt;/li&gt;
  &lt;li&gt;Fengyuan Ren, Chuang Lin, Xunhe Yin. Design a congestion controller based on sliding mode variable structure control, Computer Communications, 2005 年28(9)卷 1050-1061 页.&lt;/li&gt;
  &lt;li&gt;Fengyuan Ren, Chuang Lin, Bo Wei. A robust active queue management algorithm in large delay networks, Computer Communications, 2005 年 28(5)卷 485-493 页.&lt;/li&gt;
  &lt;li&gt;Jianer Chen, Guojun Wang, and Songqiao Chen. Locally subcube-connected hypercube networks: theoretical analysis and experimental results, IEEE Transactions on Computers, 2002 年51(5)卷 530-540 页.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-4&quot;&gt;中途退出成员提供的信息&lt;/h3&gt;

&lt;p&gt;作为前透明计算实验室的一员，来谈谈自己的想法好了。&lt;/p&gt;

&lt;p&gt;首先张的透明计算在我校是分为几个项目来做的，每个项目有一个小团队。包括PC、Android手机，平板的透明计算OS，还有基于这个“理念”的移动医疗等应用项目。&lt;/p&gt;

&lt;p&gt;这里面PC端的OS就是我所在的小团队弄出来的。&lt;/p&gt;

&lt;p&gt;其它项目团队怎么弄的我不清楚，PC端基本都是我设计的，实现方案改过几次：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;最初和Intel一起改PXE（这玩意网吧无盘就用它），想多台机器共用一个镜像，但更改的数据分别保存，搞了半天发现PXE跨不了局域网，也用不了无线，不能达到张提出的要求，被推翻了。&lt;/li&gt;
  &lt;li&gt;然后找了个开源的iPXE，号称支持广域网和无线，自定义脚本等诸多功能，整了半天把原型整出来了，又发现丫对无线的支持烂成渣，只支持一两个 802.11g的芯片组，尝试自行写无线驱动，还是不可行，因为要支持的无线网卡太多，只要有机器的网卡驱动没有，那这台机器就无法使用无线来加载透明计算系统，所以又被推翻。&lt;/li&gt;
  &lt;li&gt;截止至我离开前的方案，整了个开源的虚拟机（vbox），虚拟机上运行透明计算系统，存储的操作系统放在服务器，用iSCSI传输，运行的真正操作系统（Windows那些）上装了些自己写的程序做管理和监控。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基本结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;真实操作系统（Windows、Linux）
————————————————-
虚拟机
————————————————
透明计算管理程序
————————————————
Linux
———————————————–
机器硬件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我走之前，所在团队的工作基本上就是在定制Linux和改虚拟机。。。还为这套东西增强些功能。。&lt;/p&gt;

&lt;p&gt;对于这整套东西，我的心里话其实是：没法用。真正使用的操作系统运行在一个虚拟机上，能快到哪去？更别说镜像还是放在服务器上用iSCSI协议来传 输的。央视的新闻我看了，播到展示透明计算机器运行着XP系统的时候，我都笑傻了，为啥？Win7及更新的操作系统可是可以用，但基本慢成狗！如果再在那 上面看个视频，能有10帧就谢天谢地了！首次启动Win7至少需要5分钟以上，如果你还处于10M以下的小水管的话，呵呵呵呵。。。最好别等了。&lt;/p&gt;

&lt;p&gt;虽然团队其他人一直还在优化，但说实话效果很有限，而且这个东西我们自己都认为实在没有什么技术含量，离实用更差得远，这次听说获奖，其它团队怎么样我不清楚，但至少我们做的这个东西确实是没任何资格的。&lt;/p&gt;

&lt;p&gt;还在团队的时候，老师给派新同学进来，要跟他们解释这个东西是什么，我们的回答就是“你理解成用虚拟机搭了个网吧无盘环境就好了”。。。&lt;/p&gt;

&lt;p&gt;上面说的这些仅限我所在团队的工作内容，透明计算还有其他团队，包括其他高富帅学校也有团队在搞，他们的工作我不清楚，肯定比我们做的要高大上得多吧。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;张尧学自己的访谈&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://v.qq.com/page/h/v/q/h0145ebh1vq.html&quot;&gt;原型视频地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其获奖项目“网络计算的模式及基础理论研究”被通俗称为“透明计算”。据报道，这项研究主要在三个方面取得突破：研制了超级操作系统(Meta OS)、实现了计算与存储分离、实现了软硬件分离。&lt;/p&gt;

&lt;p&gt;计算与存储分离很早就能实现了，网吧就是这么干的；这个概念不就是甲骨文等公司20年前提出的NC(网络计算机)吗？“透明计算”的概念乍听起来与云计算似乎无异，它到底有哪些独特之处呢？冯·诺依曼结构被颠覆了吗？Intel的透明计算和张尧学的透明计算是一回事吗？一个长期担任行政职务的人怎么会有时间做科研？张尧学近日接受科技日报独家专访&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;“透明计算”与“云计算”&lt;/h4&gt;

&lt;p&gt;第一，云计算是由厂商通过服务器端的架构提供计算资源的服务，用户终端仅仅作为服务的接收端而存在，而透明计算主要关注用户端。用户需要服务时，就从服务器端将需要的软件或数据通过块或页的方式碎片化调用并主要在终端完成计算，而且终端可以装或不装任何数据、软件包括操作系统；
第二，云计算主要解决数据的海量存放和使用问题，对软件的云化、特别是操作系统的云化没有提出好的解决方案，而透明计算则较好地解决了这个问题；
第三，透明计算还包括了云计算不具备的全过程管理、带宽与缓冲管理等功能；
第四，由于云计算的重点不在终端的使用情况上，因而其在终端安全性上没有突破，而透明计算在终端安全性上有很好的考虑。&lt;/p&gt;

&lt;p&gt;“透明计算的实现可以在多个层面，例如在硬件层之上、在中间件层或在应用层。”在张尧学看来，透明计算概念的提出应该早于云计算。&lt;/p&gt;

&lt;p&gt;“云计算大概是从2008年左右被国内熟知，而我们最早做‘透明计算’相关研究是1998年，但当时我们没有称它为这个名字，这个名字是2003年左右微软亚洲研究院的一位领导在参观我的实验室时给起的。”他说。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;发端于索普卡的“透明计算”&lt;/h4&gt;

&lt;p&gt;“1998年，一台电脑的售价上万元，升级换代太快，而且病毒很多，我的想法是能不能让电脑变得更简单、更便宜、更安全和跨平台。”张尧学说，他在开发网络计算机的基础上，尝试把操作系统从原本已十分精简的终端上去掉，提出了没有操作系统的计算模式，并着手开发终端系统。&lt;/p&gt;

&lt;p&gt;网络计算机的概念20年前就已提出。张尧学说，但甲骨文等公司的网络计算机用的并不好。“Sun公司还给我们送过一套Sunray系统，一台服务器加40个终端，价格要100万多元人民币，我记得每个终端要1000多美元。虽然是赠送，但不好用，当时也只能用一个操作系统。我就考虑能不能用一种更好的方式，管理网络资源，使得计算机终端更好用、更安全，而且能兼容不同操作系统。”&lt;/p&gt;

&lt;p&gt;张尧学说，最初的研究从无盘站开始，但逐渐发现无盘站有很多局限，如只能识别一个操作系统，速度慢，执行上受用户数、对病毒防护差等的限制。“不过无盘站提供了PXE(预启动执行环境)协议，我们就在这个基础上做扩展。”&lt;/p&gt;

&lt;p&gt;几年后，张尧学的团队做出索普卡电脑。据称，这套系统相当于用一台当时的家用PC，可以带动30个终端，而且可以上多个操作系统。 “索普卡电脑的‘瘦’体现在：它本身是台裸机，没有任何软件，计算机运行所需的操作系统软件和应用软件都能从服务器下载得到。” 一篇题为《索普卡：中国PC “瘦身”之道》的报道这样写道。&lt;/p&gt;

&lt;p&gt;张尧学说，索普卡有两项专利，还转让给了联想等公司。索普卡当时在贵州、云南等偏僻地区及部分边境部队和企业应用情况良好，2003年获得教育部科技进步一等奖以及2004年度的国家技术发明奖二等奖。&lt;/p&gt;

&lt;p&gt;“但是我觉得大学里的科研人员的主要任务应该还是从理论和研究上取得突破，而不是做产品。做产业需要融资、销售和生产等专业团队，这不是我的强项，何况我还在教育部任职。所以我就开始想把索普卡往移动网络、广域网方向推，从理论上思考怎样才能在网络环境下使计算机的使用更加安全和简单。”张尧学说，他从2004年开始这方面的理论研究。&lt;/p&gt;

&lt;p&gt;张尧学于1999年至2011年任职教育部，但他告诉记者：“我在调到教育部之前已和时任教育的主管领导谈好，要继续在清华大学做科研。这位领导和清华大学都是同意的。因此，我出差很少，而且晚上和休息日基本都在实验室，这一点，我想清华大学的同事们都可以证明。”&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;与英特尔的合作&lt;/h4&gt;

&lt;p&gt;张尧学认为自己长期教授操作系统课程，以及从事协议的研究，对底层协议很熟悉。“操作系统两个最核心的内容是中断和调度，而这两个机制都是只针对单机，我就想能不能在底层硬件之上有个中间层，将操作系统和应用在内的软件从网络上加载到这个中间层上运行，并实现不同软件（包括操作系统及应用）的按需选择和按需调度，从而让不同的硬件和不同的软件系统连接。但这是一个黑匣子，需要反汇编。当时学生们做得很辛苦，后来好歹做成了，但效果不是太理想。这一是由于带宽，二是每个操作系统都要对底层反汇编，很难。”张尧学说。&lt;/p&gt;

&lt;p&gt;与英特尔的合作为该技术的更广泛应用起了很大作用。英特尔致力推广新一代BIOS及其接口标准，即EFI（可扩展固件接口），目前90%的新生产个人电脑已经采用了 EFI及其后的UEFI（统一可扩展固件接口）技术。“用EFI技术来实现透明计算，既支持多操作系统的选择和执行，又很大程度缓解了原来难以在不同硬件平台上运行问题。”&lt;/p&gt;

&lt;p&gt;谈到与英特尔的合作，张尧学说，英特尔在2005年参观了他的实验室并初步接触后，双方于2007年2月签署合作协议后长期合作“至今，我们共签有3个合作协议，Intel公司完全承认我们的知识产权。由于商业协议的条款，我不能透露太多的合作细节。但INTEL美国总部软件与服务部平台技术中心总经理MichaelA.Greene在2013年4月英特尔信息峰会期间有个主题演讲‘透明计算时代’，其中第7、第8、第9页是关于我们合作的描述。这篇讲演的PPT，就挂在&lt;a href=&quot;http://media.cs.tsinghua.edu.cn/~zyx/&quot;&gt;我的清华大学主页下&lt;/a&gt;。”&lt;/p&gt;

&lt;p&gt;“我们的目标是将底层软件做成通用软件、扩展EFI，成为国际标准。而中层和高层的透明计算实现则正在进一步研究。我认为，HTML5是实现透明计算的一种技术手段。可能理解的不对，供大家批评。”张尧学说，“至于Intel的透明计算与我提出的透明计算有什么关系？建议大家采访Intel。我在这方面有充足的证据回答大家的质疑。”&lt;/p&gt;

&lt;p&gt;他表示，目前英特尔已经在台式机、笔记本、上网本、移动互联网设备、平板电脑和智能手机等多个平台上实现了透明计算，包括上海交通大学在内的单位都已使用了英特尔的台式机透明计算系统。而不少大学则购买了由清华专利转让的台式机系统。“清华大学、中南大学和清华的毕业生还基于透明计算思想，研制成功了用手机远程使用多种操作系统和应用的手机透明计算系统等新的系统原型。这次基本上都已公开，我们的知识产权有可能会受到损失。”&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;与网络计算机等技术的区别&lt;/h4&gt;

&lt;p&gt;总结与网络计算机、远程+VPN+PNS 等技术的区别，张尧学说，“透明计算”的最大突破是提出并部分实现了使终端如何变小以及无缝连接（跨硬件和软件平台）的思想和方法。按照此方法，研制了一个分布式超级操作系统MetaOS。它不仅包括远程启动协议MRBP（I, II）、网络服务访问协议NSAP，还包括可以管理调度不同的操作系统和网络带宽等资源的I/O man以及一个轻量化的网络协议栈等，并可沿使用路径监控网络上的使用情况。他透露，最近某央企控股公司也在国家重大专项支持下基于他们的原理和早期版本研制成功了MetaOS的新版本，并有重大应用。&lt;/p&gt;

&lt;p&gt;一个理想的MetaOS能跟踪和记录来自于不同用户的访问、解决从端系统到服务器之间的各点资源的监控和管理，例如沿途的带宽、缓存等。“以前的计算机是由操作系统来调度各种软件的，但如何以碎片方式调动不同的操作系统，我没听说别人做过。”张尧学说。&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;产业化前景可期&lt;/h4&gt;

&lt;p&gt;“很多人说我们提出的计算与存储分离早就有了，我也做了十几年了，而且我们有专利。”张尧学说，“而且我们的技术可以让用户根据需要调用资源，指令是碎片化进入终端的，不是操作系统和应用程序全部，这样可以极大简化终端，带宽并不是主要问题”。&lt;/p&gt;

&lt;p&gt;他解释道，简单说来，MetaOS分为客户端和后端软件两部分。如果用户指定某台电脑为储存数据的后端，就安装后端软件，而他要用到的其他电脑、手机及可穿戴设备则需安装一个客户端软件。如此一来，他打开任何一个终端都能随意调用后端的程序和数据。清华和中南大学的透明计算研究团队则做出了更多的新产品原型，包括定制应用和不同操作系统的透明手机。&lt;/p&gt;

&lt;p&gt;他介绍道，致力于将透明计算技术产业化的工作开展，在可穿戴设备、智慧家庭、医疗和教育大数据等方面都会有巨大的应用前景。例如，今后出国不用带笔记本电脑，远在非洲就可以存取和操作在北京计算机中的资源；医生在手机上可以使用专业软件调出并分析如核磁共振影像等各种医疗数据等等。&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;第二部分 解剖张和透明计算&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Those who can, Do; and those who cann’t, Teach; and those who cann’t anything, Suck!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-12&quot;&gt;“透明计算”服务端的结构&lt;/h3&gt;

&lt;p&gt;先看看 普通电脑，云计算，chromeos，pxe 和 “透明计算” 的软硬件结构区别！&lt;/p&gt;

&lt;p&gt;一般一台计算机的软件从硬件层到外应用软件层的结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;资源供应方=用户方
核芯+主板——》基本硬件管理层（比如bois uefi）——》硬件利用层（比如linux核心）
——》基本图形系统（比如x）
——》用户界面系统（比如kde gnome）——》网络服务（远程桌面之类）
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-13&quot;&gt;资源和用户端分离的系统：&lt;/h4&gt;

&lt;p&gt;超算和云计算：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;资源端：云端服务器供应软硬件资源（核芯+主板——》基本硬件管理层——》硬件利用层——》网络服务）
——》资源管理调度接口

用户端：核芯+主板——》基本硬件管理层——》硬件利用层——》网络服务——》命令行下即可管理调度或者图形界面下管理软件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chromeos是这样的：其中的图形界面部分不同于一般的系统，比较穿透。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;资源端：云端服务器供应软硬件资源
——》资源管理调度接口

用户端：核芯+主板——》基本硬件管理层——》硬件利用层
|——》网络服务
|——》基本图形系统——》图形界面
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无盘站&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;资源供应方：云端服务器供应软硬件资源
——》远程桌面

用户端：——》用户使用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无盘站：缺陷是原有协议穿透不了局域网。&lt;/p&gt;

&lt;p&gt;超算和无盘站都是局域网，用高速网线连接的。&lt;/p&gt;

&lt;p&gt;张的透明计算：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;资源端：核芯+主板——》基本硬件管理层
|——》硬件利用层（meta os）
|——》网络服务（两个自写协议）

用户端：核芯+主板——》基本硬件管理层——》硬件利用层
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几种比较贴切的描述：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网络版bois或者uefi，且加强了功能：极其底层的系统，在一般操作系统还没启动时，就已经启动，但又还没底层到主板上的引导程序。非主板烧录的，最接近底层硬件的操作系统。&lt;/li&gt;
  &lt;li&gt;linux核心+网络服务 的弱化版：相比较linux的完整操作系统，其功能主要几种在资源组织和资源分配，功能上不如linux复杂，比如没必要管理声音和图形渲染。&lt;/li&gt;
  &lt;li&gt;超级加强版 路由器操作系统。张之前就设计过一个 网络路由器系统，现在加强其功能了：硬件兼容更强，网络功能更强大，资源调度更透明方便，可调用的资源更多。&lt;/li&gt;
  &lt;li&gt;民用版超算：非常像超算，但资源并不像超算那样集中在机房，内部用高速网线或连接线连接，而是可以使用广域网的资源（可以理解为只使用普通网线）。&lt;/li&gt;
  &lt;li&gt;底层版分布式计算：可调用不仅仅是局域网的网络资源，而且是极其底层的资源，而不是被层层包装了的网络资源、云服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以说，meta os目前仍然是世界独步的，惟一无二的，有点接近的系统应该是 超算用的系统或者是 intel之类芯片设计商之前鼓吹的，嵌入主板的 微系统。&lt;/p&gt;

&lt;p&gt;用一个通俗的比喻可能方便理解：&lt;strong&gt;在一片树林里扎篱笆，原来是在树枝上扎，后来有人在树干上扎，张的团队则是跑到根部扎。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在一片树林里扎篱笆，原来是在树枝上扎——普通分布式计算，一般僵尸网络&lt;/li&gt;
  &lt;li&gt;后来有人在树干上扎，——云计算&lt;/li&gt;
  &lt;li&gt;张的团队则是跑到根部扎——透明计算，超算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结为三句：&lt;strong&gt;系统很底层，管理的资源很广泛，资源使用非常灵活！&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;资源分布形式（待细化）&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;不同计算机模式&lt;/th&gt;
      &lt;th&gt;家用电脑&lt;/th&gt;
      &lt;th&gt;chromeos&lt;/th&gt;
      &lt;th&gt;云服务&lt;/th&gt;
      &lt;th&gt;透明计算&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;存储&lt;/td&gt;
      &lt;td&gt;本地&lt;/td&gt;
      &lt;td&gt;远程，小部分本地缓存&lt;/td&gt;
      &lt;td&gt;远程，小部分本地缓存&lt;/td&gt;
      &lt;td&gt;远程，小部分本地缓存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;运算&lt;/td&gt;
      &lt;td&gt;本地&lt;/td&gt;
      &lt;td&gt;远程&lt;/td&gt;
      &lt;td&gt;远程&lt;/td&gt;
      &lt;td&gt;远程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;管理&lt;/td&gt;
      &lt;td&gt;本地&lt;/td&gt;
      &lt;td&gt;远程&lt;/td&gt;
      &lt;td&gt;远程&lt;/td&gt;
      &lt;td&gt;远程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;界面交互渲染&lt;/td&gt;
      &lt;td&gt;本地cpu或 图芯（尽可能强）&lt;/td&gt;
      &lt;td&gt;本地弱终端（不需要强）&lt;/td&gt;
      &lt;td&gt;本地终端（可强可弱）&lt;/td&gt;
      &lt;td&gt;本地终端（可强可弱）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;细化下轻本地端的资源分布&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;内容&lt;/th&gt;
      &lt;th&gt;远程管理&lt;/th&gt;
      &lt;th&gt;远程桌面&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;交互形式&lt;/td&gt;
      &lt;td&gt;命令行&lt;/td&gt;
      &lt;td&gt;图形交互界面&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;一般远程桌面：只是一个视频录像，所有的计算都是在远程完成。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;——》远程操作系统启动后，启用网络服务
——》远程操作系统图形界面 远程渲染后以 流 方式传输到本地
《——》传入本地或远程数据
——》调用远程操作程序
——》处理后，数据返回远程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有计算都是在远程完成，但减少了不必要的开支，更省网络流量。最大化集约化简化本地终端负载：前提是网络速度足够的情况下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;——》远程操作系统启动后，启用网络服务
——》调用远程操作界面，本地渲染，
    《——》传入本地或者远程数据，
——》调用远程操作程序，
    《——处理后，数据返回远程
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-15&quot;&gt;服务端资源管理&lt;/h3&gt;

&lt;p&gt;云计算、超算等，和这个问题解决方案应该是相同的。&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;如何解决硬件兼容问题&lt;/h3&gt;

&lt;p&gt;上面是简单的基本架构，如何实现呢？&lt;/p&gt;

&lt;p&gt;如果：世界上只有一种硬件，那这一步很好办。可惜，世界上各种硬件五花八门，驱动也是五花八门。兼容问题无穷无尽，层出不穷……&lt;/p&gt;

&lt;p&gt;硬件兼容问题有多么令人焦躁呢：linux创始人针对 硬件商 直接是举中指，爆粗口。&lt;/p&gt;

&lt;p&gt;如何解决？一般的思路是简化接口，只调用不同硬件底层较为通用的接口，而规避使用那些硬件特有的接口。或者更进一步，做一个兼容层（比如kde用phonon），来转换各个硬件不同的接口，规范使用这些硬件特有接口。&lt;/p&gt;

&lt;p&gt;但这只是理论上可行，现实中需要多少工作量呢？海量！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不同指令集和底层代码，不同应用程序调用不同的库函数，就是一个“客户端”3个字这么容易？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这就是其之所以获奖的关键了，他的团队就是搞定了这个！！！！&lt;/p&gt;

&lt;p&gt;做一个兼容层确实是体力活，就是整天查对各个指令集，查找其差异和相同，然后归纳总结。&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;如何解决网络问题？&lt;/h3&gt;

&lt;p&gt;上面前团队成员暴露出来的信息看，好事多磨，在前期想偷懒，借用现成的东西，结果至少改了三次，还没真正踏进门里。最后估计是痛定思痛，干脆自己重写了两个协议才算搞定。&lt;/p&gt;

&lt;p&gt;参照清华的通报搞，很明显，在这家伙离去后，整个团队进行了重大革新。&lt;/p&gt;

&lt;p&gt;不同于&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;已有的远程启动(PXE)所使用的TFTP协议&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（单线程，速度不快，无法适应高速的界面初始化和大型任务的高速交互要求）。自己设计了一套也是底层的网络协议：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;高可靠网络协议和开发方法，研制了多操作系统远程加载协议（MRBP）和网络服务访问协议（NSAP），保证可靠的跨平台操作。&lt;/p&gt;

  &lt;p&gt;将网络互连平台由较高的网络层下降到计算机芯片和操作系统间的接口层&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;网速问题的解决：并发，分布式。&lt;/p&gt;

&lt;p&gt;多说一句：实际上，只要能够流畅视频，就足够做所有事了，反正真正计算都是在服务端，转成视频流传输就很好看了。&lt;/p&gt;

&lt;h3 id=&quot;section-18&quot;&gt;用户如何管理资源&lt;/h3&gt;

&lt;p&gt;这相对来说已经非常简单了，主要是给各个操作系统做客户端的问题，虽然仍然是兼容性问题严重，但已有现成框架基本可以胜任，体力活。&lt;/p&gt;

&lt;p&gt;目前硬件情况和软件情况，注定还无法如 服务端那样做到非常底层，但理论上是可以做到底层裸主机+客户端，但要硬件生产商配合。&lt;/p&gt;

&lt;h3 id=&quot;section-19&quot;&gt;关于操作系统和应用软件大小同步问题&lt;/h3&gt;

&lt;p&gt;应用软件的下载，大家既然习惯下载软件的等待，那这样的等待也同样应该允许在别的平台上如此，比如这个 meta os上的软件。&lt;/p&gt;

&lt;p&gt;也就是说，只要讨论系统大小和网速是否影响体验即可！&lt;/p&gt;

&lt;p&gt;1、 装操作系统的起始文件需要多大？大概10m！！！！&lt;/p&gt;

&lt;p&gt;比如装debian，只下载 linux和initrd.gz两个文件 一共6M，如果没有引导程序，再下载个引导程序，总共10m。&lt;/p&gt;

&lt;p&gt;然后从网络获取安装的所有的debian包。&lt;/p&gt;

&lt;p&gt;下载操作系统+桌面软件需要多大？&lt;/p&gt;

&lt;p&gt;damn small linux 整个系统外加浏览器总共50m！！！&lt;/p&gt;

&lt;p&gt;这可以参考 slax 这是个u盘系统，封装了kde这个大大的桌面和简单程序，总共也才200多m。&lt;/p&gt;

&lt;p&gt;debian的全软件镜像，也不过4.4 GB&lt;/p&gt;

&lt;p&gt;windows理论上也是可以这样的：但微软系统没有类似linux那样的细分，网速不够，使得这种网络安装不现实。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;我心如水_2003_PE_v19.36_珍藏版.ISO 74.3M
我心如水_Win8_x64_PE_v19.36.IS 415.8M
我心如水_XP3_2003_Win8_PE_v19.36.ISO 791.7M
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些镜像，什么东西占用最多？图片、音频、视频，还有vc运行环境。如果把这几个都缓存到本地呢？&lt;/p&gt;

&lt;p&gt;再看看一个&lt;a href=&quot;http://bbs.wuyou.net/forum.php?mod=viewthread&amp;amp;tid=356101&amp;amp;extra=page%3D1&quot;&gt;全功能镜像&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;软件镜像843.6MB
新增加的软件有：
freehand mx;
flash mx;
photoshop cs3;
coreldraw 9;
VMware Workstation 6;
光影魔术手；
Cool Edit Pro（音频处理专家）
迅雷精简版
修改QQ2014为腾迅TM(因为QQ经常更新而旧版不能使用，用TM也一样可以用QQ的大部份功能，比较稳定）；
修改Diskgenius为自己测试过的4.6.1专业版，有些版本经常出现一些错误，我用过所有版本，也就这版功能最强大最稳定了，新版还是有BUG；
WPS
OFFICE2003（短小精悍）
修改和DIY的PE工具软件，在PE中就能订制PE，不需要经常重启测试；
ADDS10硬盘分区助手；
傲梅分区助手；
重新整合了KMPLAYER播放器；（能够播放更多格式视频）
另外一些实用的小工具
……
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、对于超大软件：&lt;/p&gt;

&lt;p&gt;对于超大软件怎么办？不是流行了好长时间的C/S结构么？大的部分不需要完全下载到本地，本地弱终端。几个常用的办公用软件，目前都已有这种方案。&lt;/p&gt;

&lt;p&gt;现在对网速方面最有可能形成瓶颈的是超大型游戏！——也是有办法的，但目前还不算成熟。&lt;/p&gt;

&lt;p&gt;如果非要用nero这种分明几m就搞定（linux下刻录软件就几m）却生生整成几g的玩意，那啥网速也没办法。让这种垃圾软件死了算了。&lt;/p&gt;

&lt;p&gt;3、 这些操作系统安装所用的 包管理工具 其核心是什么？就是一个粗粒度 差分同步！&lt;/p&gt;

&lt;p&gt;所有数据，最终的存储形式都是一样，所以它们的同步方式是一样的——当然，有时为了提高效率，会使用一些特别的算法，比如压缩，调不同粒度。&lt;/p&gt;

&lt;p&gt;软件包相对文件来说更加简单粗暴：只需要名字和版本比较。&lt;/p&gt;

&lt;p&gt;4、用vnc演示的问题：用虚拟机模拟硬件和网络，比如用qemu，模拟出几台不同硬件的设备，网络方式设为桥接，就可以在一台电脑里模拟一个小型局域网，这时使用vnc有何什么需要解释的么？不用vnc的资源可控的高效管理办法，难道要逐个开小窗口？用来模拟的电脑硬件允许么？&lt;/p&gt;

&lt;p&gt;另外，我猜啊，如果真的去细究 qemu和meta os的代码，估计它们相同度肯定很高——呵呵，这不是废话嘛！底层的代码都是硬件商提供的，不相同才怪了呢。&lt;/p&gt;

&lt;p&gt;其实吧，这个演示问题还是很大的，因为他们改的底层，你改bois，或者改grub的时候，能在win里看出差别么？？？？？？&lt;/p&gt;

&lt;h3 id=&quot;section-20&quot;&gt;工程难度和工作量&lt;/h3&gt;

&lt;p&gt;就工程实现难度不低于一般的操作系统，比如linux，windows，主要是硬件方面的原因，但流行普及后，硬件兼容问题解决，会大幅度简化操作系统的设计。&lt;/p&gt;

&lt;p&gt;其实，这不是创不创新的问题，而是有没有实力的问题，很多人，都想要这么省略，甚至直接 核芯+主板+网络服务（路由器就这样的），但 核芯+主板 的产业并不掌握在自己手中，无法主导。&lt;/p&gt;

&lt;p&gt;这样不仅仅是实力，还有实战！是一手把这个极其繁重的工作给搞下来了。&lt;/p&gt;

&lt;p&gt;就工作量而言，海量的软硬件工作！&lt;/p&gt;

&lt;p&gt;另外，世界上有实力实现这个设想的，不多，也就一只手数得过来。&lt;/p&gt;

&lt;h3 id=&quot;section-21&quot;&gt;关于主动服务&lt;/h3&gt;

&lt;p&gt;其实就是 推送服务，在掌握了计算机主要资源之后，这个不难做到。&lt;/p&gt;

&lt;h3 id=&quot;section-22&quot;&gt;对张个人的理解&lt;/h3&gt;

&lt;p&gt;他应该是实战型+战略型的人物。&lt;/p&gt;

&lt;p&gt;人家是“工程院”院士！！不是中科院院士，擅长的是实现，是工程能力，实现能力，不是理论。论文？对搞工程的人来说，那都是事后有闲的时候补充论述。&lt;/p&gt;

&lt;p&gt;其所做的工作是完成了一整套完整的新型系统，这里面必然涉及到大量的技术问题和海量的工作量。能够完成，至少说明其管理能力卓越，解决问题能力卓越。&lt;/p&gt;

&lt;p&gt;结合其是解放军总装技术专家，实战部分应该是给保密单位研发操作系统了，所以大众无法了解。&lt;/p&gt;

&lt;p&gt;总之，人家提出了一个有创新性的项目，并且有效组织了一群人，通过创新的办法克服各种工程难题，实现了。获重奖无可厚非，至于获得啥级别的，看其对评估单位的重要性，所以实至名归。&lt;/p&gt;

&lt;p&gt;看看清华的通报稿，个人觉得，光这两点，就够获重奖了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;成功研制出了具有独立知识产权的，运行在各种操作系统之下、主板之上的超级操作系统（Meta OS），使用户可以根据需要，通过近乎裸机的小终端设备获取不同操作系统平台的各类服务，从而大大降低了对用户终端的要求，解决了各种操作系统安全漏洞及多操作系统的兼容与跨平台问题。&lt;/p&gt;

  &lt;p&gt;该团队还提出了高可靠网络协议和开发方法，研制了多操作系统远程加载协议（MRBP）和网络服务访问协议（NSAP），保证可靠的跨平台操作，将网络互连平台由较高的网络层下降到计算机芯片和操作系统间的接口层&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;至于那些瞎鼓噪的，借用Gentoo创始人Daniel Robbins一句话：对于工程的事，请&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;talk is cheap, show your code!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这句话也是要对张说的！&lt;/p&gt;

</description>
        <pubDate>Fri, 2015 Jan 16 12:25:20 +0800</pubDate>
        <link>http://jobinson.ga/%E6%8A%80%E6%9C%AF%E8%A7%86%E9%87%8E/2015/01/16/%E5%AF%B9%E5%BC%A0%E5%B0%A7%E5%AD%A6%E9%80%8F%E6%98%8E%E8%AE%A1%E7%AE%97%E7%9A%84%E7%90%86%E8%A7%A3/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E6%8A%80%E6%9C%AF%E8%A7%86%E9%87%8E/2015/01/16/%E5%AF%B9%E5%BC%A0%E5%B0%A7%E5%AD%A6%E9%80%8F%E6%98%8E%E8%AE%A1%E7%AE%97%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
      </item>
    
      <item>
        <title>牛排和弓形虫</title>
        <description>&lt;p&gt;关于宠物和弓形虫和怀孕，我们太多误区了……&lt;/p&gt;

&lt;p&gt;首先，拿被列为弓形虫感染罪魁祸首的猫来说：&lt;strong&gt;不是每只猫都有弓形虫的，人家也是被感染的&lt;/strong&gt;，家养的大多数不出门的猫咪是没有的，的确，&lt;strong&gt;猫被感染后会终身携带弓形虫，但是排出体外只有一次，一生只有一次！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;即&lt;strong&gt;在被感染的几天内的首次代谢中随粪便排出，此后体内长期携带但不会再排出&lt;/strong&gt;。（狗根本就不是弓形虫的最终宿主，更不用提了。）&lt;/p&gt;

&lt;p&gt;而排出的弓形虫是不是马上就会感染人类呢？不是！&lt;strong&gt;弓形虫卵需要与空气接触并孵化约48小时才具有传染性&lt;/strong&gt;，也就是&lt;strong&gt;在这期间只要及时处理粪便，不给虫卵孵化的机会，传染完全可以避免。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;再说即使传染了，也不是洪水猛兽，因为&lt;strong&gt;弓形虫感染和起水痘一样，对人类而言，一生中不可能有第二次。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;绝对多数正常人在感染弓形虫后没有不适反应，少数身体虚弱的人会有类似发烧症状，随后&lt;strong&gt;人体自然产生抗体，并对其终身免疫。&lt;/strong&gt;这期间弓形虫对人体造成的伤害微乎其微，偶有特殊体质特殊案例其几率小于等于中五百万大奖。&lt;/p&gt;

&lt;p&gt;只有当弓形虫的初次感染者不巧处于怀孕初期，会有一定几率不幸使婴儿产生畸形或者流产等悲剧。免疫者则并不受影响。&lt;/p&gt;

&lt;p&gt;那我们来算算这个悲剧由猫狗造成的机率有多大？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一，你家的猫狗刚好不幸接触并感染了弓形虫。&lt;/li&gt;
  &lt;li&gt;第二，它唯一一次排出的带有弓形虫卵的粪便刚好在空气中足足孵化够了48小时成为具有传染性病原。&lt;/li&gt;
  &lt;li&gt;第三，你刚好触碰到了这些粪便并没有及时清洁而是将其带入体内。&lt;/li&gt;
  &lt;li&gt;第四，你之前养了很多年都没有机会传染过却正好在你刚怀孕的初期被第一次传染了……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;自己算算吧……中了的话可以去买彩票了。&lt;/p&gt;

&lt;p&gt;但是很多孕妇的确很不幸的感染了弓形虫，这种巧合也许的确成立，但是，但是，你真的确定你家的猫狗是这起不幸的罪魁祸首吗？！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;弓形虫感染源于生食习惯！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;绝大多数人感染弓形虫是因为生食。弓形虫卵广泛存在于很多动物体内，当人吃到这些没有被充分加热煮熟的含有弓形体包囊的动物组织，弓形虫自然病从口入了。
不过，虽然中国的食品卫生问题一直差强人意，但弓形虫感染率却是全世界最低的国家之一，大多在10%以下，这与中国人习惯熟食关系很大。&lt;/p&gt;

&lt;p&gt;英、美的成年人中，大约16-40%发生过感染，有的调查达到70%，欧洲大陆和拉丁美洲的成年人，50-80%发生过感染，法国人高达90%。法国人是众所周知活的在意，特拿自己的命当回事的人了，90%的人发生过感染，要是有大事的话，法国不早闹翻天了？而&lt;strong&gt;法国人这么高的感染率不是因为宠物，而是因为牛排！五成熟的牛排！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以怀孕的女人如果要杜绝弓形虫，要做的第一件事决不应该是把家里可怜的小猫小狗扫地出门。&lt;strong&gt;所有入口的食物确实洗干净煮熟了&lt;/strong&gt;才最要紧啊！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;人养猫养狗已有几千年历史,当真能对孕妇造成传说中的那么大的伤害的话,人早就应该认识到了,还用得着现在才瞎嚷嚷。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 2014 Nov 03 15:39:13 +0800</pubDate>
        <link>http://jobinson.ga/%E4%BF%9D%E5%81%A5/2014/11/03/%E7%89%9B%E6%8E%92%E5%92%8C%E5%BC%93%E5%BD%A2%E8%99%AB/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E4%BF%9D%E5%81%A5/2014/11/03/%E7%89%9B%E6%8E%92%E5%92%8C%E5%BC%93%E5%BD%A2%E8%99%AB/</guid>
      </item>
    
      <item>
        <title>使用metalsmith生成静态网站</title>
        <description>&lt;mark&gt;特别提醒：不要把时间浪费在迁移平台上！&lt;/mark&gt;

&lt;p&gt;问题发生：
近一个月来，发现github的页面不会更新了，试了很多方式，都不更新——后来，才想起升级过git版本，新版本快速提交时对深度路径压缩不正确，导致出问题！解决办法是删了该目录后提交，再恢复该目录，再提交。&lt;/p&gt;

&lt;p&gt;折腾过程中，顺便就查了下各个语言的生成器，量真多，几乎每个语言都有若干个。
个人主要关注几个关注量大，且所用语言个人比较看好或者常用的。&lt;/p&gt;

&lt;p&gt;别人认为的槽点如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;ruby的中文编码问题：不支持中文的url路径？还有tag名称如果设置为中文，则不可以使用site.tags.TAG这种用法筛选文章，简直就是坑。&lt;/li&gt;
    &lt;li&gt;功能还是比较欠缺。只有一个分页器？还只能在index下分页？还有那个坑爹的liquid模板，不如直接上erb（当然作者是为了github的安全着想）。&lt;/li&gt;
    &lt;li&gt;不想装ruby&lt;/li&gt;
    &lt;li&gt;不熟悉ruby&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ruby&quot;&gt;ruby&lt;/h3&gt;

&lt;p&gt;jekyll 本人第一个深入使用的静态站生成器，使用量极高&lt;/p&gt;

&lt;p&gt;模板语言erb语法：属于Ruby标准库中的东西，不需要单独安装，模板中动态脚本的写法和JSP基本一个模子扒出来的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;% 写逻辑脚本(Ruby语法) %&amp;gt;
&amp;lt;%= 直接输出变量值或运算结果 %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;js&quot;&gt;js&lt;/h3&gt;

&lt;p&gt;有好多个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;metalsmith 全插件化，可从简到复杂，可定制性高&lt;/li&gt;
  &lt;li&gt;hexo 台湾一学生搞的，支持多线程生成，上百个文件只需要花数秒中就能生成，可自动提交，应该算js版的octopress。&lt;/li&gt;
  &lt;li&gt;harp 零配置起步——要不分支为sharp？&lt;/li&gt;
  &lt;li&gt;assemble&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;consolidate.js 模板中介&lt;/p&gt;

&lt;p&gt;liveload.js 根据更改，可即时刷新&lt;/p&gt;

&lt;p&gt;生成静态站：coffeescript&lt;/p&gt;

&lt;p&gt;前端：angular+动态响应&lt;/p&gt;

&lt;h3 id=&quot;coffeescript&quot;&gt;coffeescript&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;docpad&lt;/li&gt;
  &lt;li&gt;Wintersmith&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;其他&lt;/h3&gt;

&lt;p&gt;常见的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sphinx：python写的，经常用于生成技术文档&lt;/li&gt;
  &lt;li&gt;org-mode：其周边成熟度很高，个人用的也不少，不过，因为其对内嵌代码的设计有严重缺陷，而且广泛的使用率，使其改进的难度会变得极大！因此个人觉得除非开个分支改进否则很令人失望。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，还有几个特别的，比如直接用makefile来生成的&lt;/p&gt;

&lt;h2 id=&quot;metalsmith&quot;&gt;为何选用metalsmith&lt;/h2&gt;

&lt;p&gt;metalsmith的特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;全部插件化&lt;/li&gt;
  &lt;li&gt;核心很小，就一个调用程序，处理目录，输入输出的接口层（标准接口层），复制文件夹和文件到另一个文件夹和文件——此方法很值得借鉴！&lt;/li&gt;
  &lt;li&gt;灵活性大，可以生成各种类型项目：静态站，项目架构，生成工具，电子书，项目文档等，只要定义好模板。——相当于一个格式转换中心，从简单到复杂。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几个插件化比较彻底的项目：gulp 插件化构建测试套装工具，consolidate.js模板，metalsmith构建中心。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;安装环境&lt;/h2&gt;

&lt;p&gt;一，安装 node.js，安装方法见nodejs文档。&lt;/p&gt;

&lt;p&gt;二，然后，安装metalsmith外&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install metalsmith -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三，安装一些需要的插件：下面列出一些一般需要的。&lt;/p&gt;

&lt;p&gt;内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;templates：布局模板&lt;/li&gt;
  &lt;li&gt;markdown：内容源码形式&lt;/li&gt;
  &lt;li&gt;ignore：忽略掉一些文件，典型的如 &lt;em&gt;readme.md&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;页面部件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;assets：不转换、保持原样的部分&lt;/li&gt;
  &lt;li&gt;beautifier：为运行效率考虑，一般不需要。但为了方便检查代码生成结果，需要。&lt;/li&gt;
  &lt;li&gt;collections：分类&lt;/li&gt;
  &lt;li&gt;navigation：根据文件树输出导航&lt;/li&gt;
  &lt;li&gt;paginate：分页&lt;/li&gt;
  &lt;li&gt;permalinks：给网页一个固定链接&lt;/li&gt;
  &lt;li&gt;tags：文章标签&lt;/li&gt;
  &lt;li&gt;autotoc：自动生成文内目录——目前这个不好用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用于辅助编写&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;less.js 辅助编写css&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用于压缩生成代码所需的插件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTML Minifier：压缩html页面&lt;/li&gt;
  &lt;li&gt;压缩css&lt;/li&gt;
  &lt;li&gt;压缩js&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用于测试&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;gulpsmith metalsmith+gulp.js&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;新建项目&lt;/h2&gt;

&lt;p&gt;可以从metalsmith源码中的example中复制一份，然后根据需要修改。&lt;/p&gt;

&lt;p&gt;也可以按照新建一个 nodejs 项目一样，新建一个，这样通用性较好。&lt;/p&gt;

&lt;p&gt;最终的文件结构可能如下：和一般的nodejs项目类似。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|– source/     需要被转换的内容
    |– content/
    |– images/
    |– styles/
    |_ scripts/
|– templates/    模板
|   |_ partials/
|– build/       生成的静态站点
    |– content/
    |– images/
    |– styles/
    |_ scripts/
|– node_modules/    开发所需的模块        
|– config.json
|– index.js     项目启动文件，metalsmith总控配置就放在这
|_ package.json    项目配置文件
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;packagejson&quot;&gt;项目所需插件：package.json&lt;/h2&gt;

&lt;p&gt;编辑 package.json，添加所需的依赖模块，然后安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install --save-dev metalsmith
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;indexjs&quot;&gt;配置：index.js&lt;/h2&gt;

&lt;p&gt;编辑 index.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Metalsmith = require(&#39;metalsmith&#39;);
Metalsmith(__dirname)
  .destination(&#39;./build&#39;)
  .use(drafts())
  .use(markdown())
  .use(permalinks(&#39;posts/:title&#39;))
  .use(templates(&#39;ejs&#39;))
  .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;各句解释：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;var Metalsmith = require(&#39;metalsmith&#39;);&lt;/code&gt; 调用 metalsmith&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;__dirname/src&lt;/code&gt; 指定需要转换的目录，比如此处是  &lt;code&gt;/src&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;.destination(&#39;./build&#39;)&lt;/code&gt; 指定输出到 build文件夹&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;.use(drafts())&lt;/code&gt; 使用 草稿箱&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;.use(markdown())&lt;/code&gt; 指定输入的格式为markdown文件&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;.use(permalinks(&#39;posts/:title&#39;))&lt;/code&gt; 设定固定链接形式&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;.use(templates(&#39;ejs&#39;))&lt;/code&gt; 指定输出时使用的转换模板ejs&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;.build();&lt;/code&gt; 生成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果不指定转换模板，则只是简单的 复制源码文件夹 到 输出文件夹。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;转换模板语言选用&lt;/h2&gt;

&lt;p&gt;metalsmith用consolidate.js，来作为各种模板语言中介。&lt;/p&gt;

&lt;p&gt;模板引擎会根据每个文件头部的 yaml格式 的 设定，进行转换。&lt;/p&gt;

&lt;p&gt;模板语言是生成的时候要运行的部分。&lt;/p&gt;

&lt;p&gt;js则是用户打开的时候才会用的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jade 语法和内容易混，缩进在不同编辑器中显示不一，特蛋疼&lt;/li&gt;
  &lt;li&gt;swig 语法借鉴jinja2 功能全，使用 &lt;code&gt;{}&lt;/code&gt; 标记&lt;/li&gt;
  &lt;li&gt;handlebars 非常少逻辑的模板，类似mustache，但比其稍强 使用 &lt;code&gt;{}&lt;/code&gt; 标记：没有if else for等，只有标签，标签用于替换各种东西。&lt;/li&gt;
  &lt;li&gt;Underscore 用的 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;ejs 无标签注记，无区块（有include） &lt;code&gt;&amp;lt;% code %&amp;gt;&lt;/code&gt; 筛选，可自定义标记，有客户端渲染器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为是静态站，此处不考虑模板引擎的效率&lt;/li&gt;
  &lt;li&gt;不知道会不会出现liquid的自身难以完整表达自身的问题？？？——liquid社区竟然认为那是一个功能，而不是缺陷！！！！&lt;/li&gt;
  &lt;li&gt;个人认为不应该给html增加一个标识符&lt;code&gt;{}&lt;/code&gt;，而应该使用原有的&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;，比如&lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;? ?&amp;gt;&lt;/code&gt;，目的是减少处理和识别复杂度。因此选用ejs。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;要是当初html设计成类似lisp那样的标识前置简化语法，可以省好多，没办法，html是事实标准，就只能跟标准妥协了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外，觉得php其实是一个伪装成编程语言的模板语言！！(带交互响应的)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php xxx ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果把php当成静态站的模板，需要剥离php的交互响应部分，把需要高度交互响应的，换用性能更强劲的部件。而不极限于php。&lt;/p&gt;

&lt;p&gt;技术演进：
php/asp+html+js+css，重心在php&lt;/p&gt;

&lt;p&gt;由于普及率问题，现在演变成了：
html+css+js+各种js模板。重心在js&lt;/p&gt;

&lt;h2 id=&quot;ejs&quot;&gt;ejs模板语言&lt;/h2&gt;

&lt;p&gt;ejs特点：不支持模板继承，但可用include实现类似效果。可自定义标记，可用于客户端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 用=号输出,会被escape转义编码
&amp;lt;%= 输出变量 %&amp;gt;
// 用“-”输出原始内容, 不会被escape
&amp;lt;%-输出变量是不会对 &amp;amp; 等符号进行转义的 &amp;lt;%# 注释 %&amp;gt; &amp;lt;%%  输出一 &amp;lt;%
&amp;lt;% if (names.length) { %&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;% names.forEach(function(name){ %&amp;gt;
      &amp;lt;li foo=&#39;&amp;lt;%= name + &quot;&#39;&quot; %&amp;gt;&#39;&amp;gt;&amp;lt;%= name %&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;% }) %&amp;gt;
  &amp;lt;/ul&amp;gt;
  &amp;lt;% } %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用 片段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
  &amp;lt;% users.forEach(function(user){ %&amp;gt;
    &amp;lt;% include user/show %&amp;gt;
  &amp;lt;% }) %&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;生成&lt;/h2&gt;

&lt;p&gt;使用nodejs来生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node index.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可用metalsmith，前提是配置内容写在 metalsmith.json &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;metalsmith
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;测试和预览&lt;/h2&gt;

&lt;p&gt;选用 gulp.js 来测试。到目录下，然后安装 gulp.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd &amp;lt;YOUR_PROJECT&amp;gt;
$ npm install gulp --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后新建一文件 gulpfile.js ，内容填入：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.robinthrift.com/posts/getting-to-know-metalsmith/&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 2014 Sep 13 12:15:31 +0800</pubDate>
        <link>http://jobinson.ga/%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%B7%AF/2014/09/13/%E4%BD%BF%E7%94%A8metalsmith%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%B7%AF/2014/09/13/%E4%BD%BF%E7%94%A8metalsmith%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/</guid>
      </item>
    
      <item>
        <title>静态网站变成动态网站</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;利用外部资源&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;添加评论系统&lt;/h3&gt;

&lt;p&gt;Jekyll生成的是静态网站，诸如评论、推荐、关注之类的功能，则需把各种各样第三方的功能部件加到你的博客中。&lt;/p&gt;

&lt;p&gt;与博客相关的主要有几类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;社会化评论：专门提供评论功能的网站，可以为博客增加评论功能，也可能附带着关注、相关文章、推荐等功能。国外的有disqus，国内的有友言，多说&lt;/li&gt;
  &lt;li&gt;社会化推荐：自动推荐相关文章（站内或站外）。国内的有友荐，无觅。Jekyll本身也可以实现站内文章推荐的功能。&lt;/li&gt;
  &lt;li&gt;社会化分享：将自己喜欢的网址分享给别人，通常附带推荐功能。国内的有加网 ，百度分享等。其中加网提供了划词分享功能。&lt;/li&gt;
  &lt;li&gt;社交网站联动：可以发布简短的动态。比如Twitter, Facebook, Google Plus, 新浪微博等网站。与博客的联动可以是自己发布博客动态，也可以是由别人推荐（这种方式即为社会化推荐）。
如果是自己发布动态，需要让别人能够方便的“关注/Follow”你，最好提供“一键关注的按钮”，或者提供连接能够让别人在这些网上方便的找到你。&lt;/li&gt;
  &lt;li&gt;社会化登录：就是OpenID或OAuth的集合。暂时不予考虑。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于存在着伟大的墙，只好尽量选择国内的社会化网络资源。对于更喜欢的国外的资源，尽量考虑如何不拖慢墙内用户的访问速度。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;评论功能&lt;/h3&gt;

&lt;p&gt;只选一个，选了友言。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;推荐功能&lt;/h3&gt;

&lt;p&gt;友言 本身就有了，所以不用去考虑。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;分享功能&lt;/h3&gt;

&lt;p&gt;友言本身也有了，不考虑了。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;流量分析和统计&lt;/h3&gt;

&lt;p&gt;第三方的流量分析和统计工具可以说是很多，国外的Google Analysis、SiteMeter和国内的百度统计、量子恒道统计等。&lt;/p&gt;

&lt;p&gt;为了减少翻墙需求，还是选择国内的吧，选了百度——不过我可以说百度做的真差么？&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;脱胎换骨&lt;/h1&gt;

&lt;h2 id=&quot;markdown&quot;&gt;换markdown渲染核心&lt;/h2&gt;

&lt;p&gt;注：由于一些代码在liquid的转码中出现问题，因此，有必要对照着源码，&lt;a href=&quot;https://github.com/jobinson99/jobinson.github.io&quot;&gt;源码库在此&lt;/a&gt;
jekyll2默认用的 kramdown，换！
github网站提供的编译器版本比较注重安全性，因此会关闭一些功能。&lt;/p&gt;

&lt;p&gt;为了解决这些问题，改用pandoc渲染，相应的：关闭掉github本身提供的渲染功能。
获得的好处：文内导航自动生成，支持数学公式，支持表格等！&lt;/p&gt;

&lt;p&gt;另外，最新的bootstrap也基于jekyll了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jekyllrb.com/docs/plugins/&quot;&gt;插件安装参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;公式解决：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;js&quot;&gt;利用js使页面动态响应&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;简单的根据用户显示内容&lt;/li&gt;
  &lt;li&gt;从别的网站获取新闻，用户每次查看都是最新新闻&lt;/li&gt;
  &lt;li&gt;在线编辑&lt;/li&gt;
  &lt;li&gt;提交成果到成果库：利用git.js&lt;/li&gt;
  &lt;li&gt;在线交流：together.js&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;添加动态编程环境&lt;/h2&gt;

&lt;p&gt;codemirror？制作一个编程环境&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;在线提交&lt;/h2&gt;

&lt;p&gt;利用 github.js 实现在线提交！——但安全性较差，一般只用在本地js编程环境下，当然，如果有隐藏办法也是可以的，但防君子不妨小人！&lt;/p&gt;

</description>
        <pubDate>Mon, 2014 Sep 01 20:01:01 +0800</pubDate>
        <link>http://jobinson.ga/%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%B7%AF/2014/09/01/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%8F%98%E6%88%90%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%B7%AF/2014/09/01/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%8F%98%E6%88%90%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99/</guid>
      </item>
    
      <item>
        <title>易码肆的码道技巧</title>
        <description>&lt;p&gt;既然选用码道来作为主要的文档格式，那么一个适手的工具就是必须的了。本人选用的是：易码肆（emacs）+码道中文模式（markdown-zh）&lt;/p&gt;

&lt;p&gt;码道中文模式是我个人改造的，&lt;a href=&quot;https://github.com/i-org/markdown-mode-zh&quot;&gt;可在此下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;另外，为了让生产线更高效，还有一个中文版的成果管理工具：&lt;a href=&quot;https://github.com/i-org/egg-zh&quot;&gt;鹅哥哥成果管理&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;snippet&quot;&gt;利用snippet&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://mad4a.me/2012/08/02/emacs-summary-cont/#outline_2&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;添加几个常用的代码片段&lt;/h3&gt;

&lt;p&gt;新建几个snippet，内容如下：&lt;/p&gt;

&lt;p&gt;插入头部：h（还有大bug）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-
# name: head-info
# --
---
layout: post
title: &quot;`(mis-remove-date (mis-extract-file-name (buffer-name)))`&quot;
date: `(format-time-string &quot;%Y-%m-%d %H:%M:%S %z&quot;)`
description: &quot;&quot;
categories: `(buffer-file-name)`
tags: [${1:话题}]
lastmod: 
--- 

$0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我的看法：a&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-
# name: aside
# --
&amp;lt;aside&amp;gt;&amp;lt;b&amp;gt;黑传说看法：&amp;lt;/b&amp;gt;${1:}&amp;lt;/aside&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加粗+背景色：bbc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-
# name: bold+background-color
# --
&amp;lt;b style=&quot;background-color:${1:};&quot;&amp;gt;${2:文本}&amp;lt;/b&amp;gt; $0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;背景色:bc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-
# name: background-color
# --
&amp;lt;span style=&quot;background-color:${1:};&quot;&amp;gt;${2:文本}&amp;lt;/span&amp;gt; $0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字体颜色:fc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-
# name: font-color
# --
&amp;lt;span style=&quot;color:${1:};&quot;&amp;gt;${2:文本}&amp;lt;/span&amp;gt; $0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;高亮文本：m&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-
# name: highlighted text
# --
&amp;lt;mark&amp;gt;${1:文本}&amp;lt;/mark&amp;gt; $0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;圈字：q&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-
# name: border-around
# --
&amp;lt;span style=&quot;border: 2px solid black; border-radius: 30px;&quot;&amp;gt;${1:圈字}&amp;lt;/span&amp;gt; $0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;简化图片插入操作&lt;/h3&gt;

&lt;p&gt;图片路径安排：每篇文章一个图片文件夹&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;| --- _posts
|       | --- 2012-07-31-hello-world-again.md
|       | --- 2012-08-01-emacs-summary.md
|       | --- 2012-08-02-emacs-summary-cont.md
|
| --- assets
|       | --- images
|       |       | --- emacs-summary
|       |       |       | --- emacs-screenshot.png
|       |       |
|       |       | --- emacs-summary-cont
|       |       |       | --- post-meta-screenshot.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要达到的目的：仅仅用上下方向键选择图片。&lt;/p&gt;

&lt;p&gt;需要创建两个文件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;修改emacs 配置文件：用于获取图片路径和列出图片&lt;/li&gt;
  &lt;li&gt;yasnippet文件：用于调用上面的配置文件中设定的函数，选择图片。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;姑且把emacs配置文件单独存为一个 el文件，命名为 &lt;code&gt;markdown-image-select.el&lt;/code&gt; 填入以下内容：&lt;/p&gt;

&lt;p&gt;yasnippet文件， 姑且命名为 &lt;em&gt;i&lt;/em&gt;，填入内容：（注意不要换行）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![${1:$$(yas-choose-value (mis-yield-choices (buffer-file-name)))}](/static/images/`(mis-get-directory-from-bufname (buffer-file-name))`/$1)$0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，修改下emacs的配置，调用 &lt;code&gt;markdown-image-select&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最后一步，重启emacs&lt;/p&gt;

</description>
        <pubDate>Thu, 2014 Jul 24 22:01:11 +0800</pubDate>
        <link>http://jobinson.ga/%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%B7%AF/2014/07/24/%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E7%94%9F%E6%88%90%E5%99%A8/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%B7%AF/2014/07/24/%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      </item>
    
      <item>
        <title>大人格和小人格</title>
        <description>&lt;p&gt;不可以用对匹夫匹妇的道德水平来要求在历史上有重大影响的人物。&lt;/p&gt;

&lt;p&gt;和尚应该吃肉，批量饲养的肉应该吃；但不能乱吃肉，野生的一般不吃，但严重破坏生态平衡的要吃。&lt;/p&gt;

&lt;p&gt;理由有三：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;现在大部分肉都是饲养的，这些肉的销售，可以养活了好几家人，甚至几十家，几百家人。&lt;/li&gt;
  &lt;li&gt;这些肉不断被高速消化，会促进这些生物本身的生育和长成。&lt;/li&gt;
  &lt;li&gt;吃肉有助于身体发育，有了强健的身体，有助于创造更多的价值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，帮助消化这些肉，不仅不会犯杀生，甚至有助于 乐生 。&lt;/p&gt;

&lt;p&gt;这是大仁！&lt;/p&gt;

&lt;p&gt;帮助植物或者动物繁育，帮助人过日子，或者帮人能养育人口，这些都是大仁！&lt;/p&gt;

&lt;p&gt;大仁可不拘戒律，戒律只是为了给那些自控差的人用的，毕竟绝大部分人都是自控差的。&lt;/p&gt;

&lt;p&gt;追求大仁者，有可能是因为本身小仁无法追求，比如我，然后移情到大仁上，或者说是不想众生和我一样遭遇那样的困苦，因此想在自己能力范围内，帮大众规避这种困难。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;道德困扰了中国人&lt;/h2&gt;

&lt;p&gt;原文作者李敖，我把里面那些偏执、不符合历史和现实的东西改写掉。&lt;/p&gt;

&lt;p&gt;中国人在几千年残酷的生活中，总结出了一套有助于改善自身生存的规则，演化为日常生活中的伦理道德。&lt;/p&gt;

&lt;p&gt;而伦理道德被发明以后，又具备了自身的独立生命力，被经常用来判断一个人或者一件事，甚至极端到“泛道德主义”，就是什么都要道德一下，该道德的固然道德，不道德的也照道德不误，道德定了。&lt;/p&gt;

&lt;p&gt;流风所至，人们经常会把一切都先来个二分法，什么都先劈头来个大分类，像小孩子问“好人” “坏人”一样，先用“道德的”或“不道德的”来检查一切。 &lt;/p&gt;

&lt;p&gt;这种极端做法，使人不太承认在“道德的”或“不道德的”的以外，还有一种“跟道德不相干的”第三势力存在，甚至还想把第三势力也道而德之：&lt;/p&gt;

&lt;p&gt;例如“玉”有什么道德不道德？可是中国人说“玉石之美有五德”；“鸡”有什么道德不道德？可是中国人说“鸡有五德”；“天地”有什么道德不道德？
可是中国人说“天地不仁”或“天地大德”。……&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;仁困扰了孔夫子&lt;/h3&gt;

&lt;p&gt;从“论语”里，我们经常可以发现这种困扰的文字。
以管仲的人格问题为例：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;子贡曰：“管仲非仁者与？桓公杀公子纠，不能死，又相之。”
子曰：“管仲相桓公，霸诸侯，一匡天下，民到与今受其赐。微管仲，吾其被髡左衽矣！岂匹夫匹妇之为谅也，自经于沟渎而莫之知也！”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;翻译：子贡问：“管仲的人格有问题罢？齐桓公杀了公子纠，管仲是公子纠的人，他不能为公子纠殉难，反倒替齐桓公当家，管仲的人格有问题罢？”
孔夫子答：“管仲帮齐桓公，尊王攘夷，一统天下，老百姓直到今天还得到他的好处，没管仲，连我今天都要因亡国而做胡人打扮了！管仲是大处着眼的人，他哪里会像一般匹夫匹妇一样，没没无闻去殉难，没没无闻的去守那些匹夫匹妇的人格标准呢！”&lt;/p&gt;

&lt;p&gt;子贡的困扰，同样发生在子路身上： &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;子路曰：“桓公杀公子纠，召忽死之，管仲不死，曰：未仁乎？”
子曰：“桓公九合诸候，不以车兵，管仲之力也。如其仁！如其仁！”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;翻译：子路问：“齐桓公杀了公子纠，召忽殉难，为公子纠死了，管仲却偷生，人格有问题罢？”
孔夫子答：“齐桓公多次召集群雄，不用武力，全是管仲的功劳。管仲是大处着眼的人，这就是他伟大的人格啊！非常伟大！”&lt;/p&gt;

&lt;p&gt;孔夫子给两个学生的答案，都是在说管仲具有和普通人不一样的 “仁” 。&lt;/p&gt;

&lt;p&gt;孔夫子死后，后代的人，几乎全在孔夫子思想大磁场下做“指南针”，一直不敢“代圣人立言”，以致孔夫子的思想，非但不能被“继绝学”，反倒其学愈继愈绝。
千百年来，他的思想一直被匹夫匹妇思想家解释着，自然百孔千疮、一丘之貉。 &lt;/p&gt;

&lt;p&gt;在答复两个学生的“道德审判”里，孔夫子把“仁”字来做“统摄诸德完成人格”的总辞汇，但没有区分“大仁”和“小仁”。
而且，随着时间的推移，这个“仁”字内涵是有变化的。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;大人格与小人格&lt;/h3&gt;

&lt;p&gt;孔夫子的“仁”，包含着“人格的两层面”：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第一层面是“管仲的层面”：是大人物的层面、是特立独行的层面、是大无畏的层面、是“虽千万人，吾往矣！”的层面；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第二层面是“匹夫匹妇的层面”：是小市民的层面、是随波逐流的层面、是依附权势的层面、是“庸德之行，庸言之谨”的层面。 &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;大人格：管仲的层面&lt;/h3&gt;

&lt;p&gt;“管仲的层面”所表现的人格，叫“大人格”；“匹夫匹妇”所表现的，叫“小人格”。
“大人格”的表现因为是特立独行的、是大无畏的、是“虽千万人，吾往矣！”的，自然跟“小人格”的表现冲突，尤其是“大人格”尚未功成名就前，这种冲突，更为显著。&lt;/p&gt;

&lt;p&gt;管仲在尚未功成名就前，与朋友做生意，要多分钱，在“小人格”标准，这是吃人；
管仲为朋友办事，给办砸，在“小人格”标准，这是害人；
管仲同朋友出征，作战时退后，凯旋时在前，在“小人格”标准，这是胆怯；
管仲在公子纠被杀，朋友殉难，反倒投奔敌人，在“小人格”标准，这是无耻。……&lt;/p&gt;

&lt;p&gt;即使在管仲功成名就以后，在“小人格”标准下，他的作风，也可议颇多，孔夫子以“小人格”标准看管仲，就骂出“管仲之器小哉！”的话、就骂出“管氏而知礼，孰不知礼！”的话。&lt;/p&gt;

&lt;p&gt;管仲的一切不合“小人格”标准的行径，虽为大家所不谅，但他的朋友鲍叔牙却一直信任他、一直让他。
最妙的，在管仲临死前，齐桓公来问他谁做他的接班人，他竟不推荐曾推荐他的鲍叔牙，理由是鲍叔牙不能搞政治。
这在“小人格”的标准下，十足是忘恩负义了，但在“忠于为国，不私其友”的“大人格”标准下，管仲却能天下为公。
管仲所以为管仲、所以伟大，就在于这里！ &lt;/p&gt;

&lt;p&gt;以孔夫子的深明大义，都难免用过“小人格”标准看管仲，可见“小人格”标准在社会上多么流行。
“小人格”标准是“匹夫匹妇的层面”，是随波逐流的、依附权势的、“庸德之行，庸言之谨”的，这种标准的泛滥下，胸怀“大人格”标准的英雄豪杰，都会长期遭到舆论、谣言、群众、世俗的打击。&lt;/p&gt;

&lt;p&gt;所以，“父子责善” 的贤人 匡章，全国说他不孝；“弟死不葬”的志士张良，社会说他不仁；周公旦 被诬不利孺子；直不疑 被诬与嫂通奸；马援 被诬贪污；张自忠被骂汉奸，蒙羞六七载；岳飞不得昭雪，沉冤二十年。
……&lt;/p&gt;

&lt;p&gt;多少大丈夫，在“小人格”标准下，都变成了“人格有问题”的下三烂，这种不公道局面的形成，毛病出在哪儿呢？ &lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;小人格：匹夫匹妇的层面&lt;/h3&gt;

&lt;p&gt;毛病出在“匹夫匹妇的层面”。&lt;/p&gt;

&lt;p&gt;“匹夫匹妇的层面”所见者小，这种层面的“道德判断”，只是小市民的横断面，小市民只会从个人的利益、家族的利益、朋友的利益、宗教的利益、职业的利益、帮派的利益和党的利益检定人格，
他们要求的人格标准也只是他们小圈圈的人格标准，在小圈圈内，他们不失为好丈夫、好朋友、好龙头、好领袖，但在小圈圈外，他们都是魔鬼。&lt;/p&gt;

&lt;p&gt;黑龙会头子、黑手党教父在小圈圈内是最够朋友的，但在小圈圈外是无恶不作的；
公孙弘小圈圈外内是第一流的孝子、第一流节俭的人，但在小圈圈外，他是第一流的奸臣。&lt;/p&gt;

&lt;p&gt;用“小人格”标准看，甘地最不够朋友，因为他主张人要为真理牺牲朋友，甘地的人格有问题！
用 “小人格”标准看，文天祥忠而忘孝、生活奢侈，文天祥的人格也有问题！ &lt;/p&gt;

&lt;p&gt;因为社会上匹夫匹妇多，检定人格的标准，自也就匹夫匹妇化，匹夫匹妇只注重小团体利益，缺少对社会整体的真理与正义；
只会以偏盖全，缺少大处着眼。
所以，常常有很好很好的人，反被视为坏蛋、被视为“人格有问题”。 &lt;/p&gt;

&lt;p&gt;很坏很坏的人，发现匹夫匹妇的“小人格”标准原来这样，发现匹夫匹妇只注意“小人格”而不知“大人格”，于是他们便从“小人格”毁掉异己、斗臭政敌、破坏“非我族类”的“大人格”形象。
他们的方法是迂回的：报纸的围剿、口语的相传、朋友的诬控、妻子的伪证、罪名的离奇、审判的丑化等等，都是他们的拿手好戏。 &lt;/p&gt;

&lt;p&gt;结果是，“道德迷”的中国人，很容易便在“道德判断”上中计，硬说谁谁谁“人格有问题”。然后喊打喊杀，口水直溅。 &lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;管仲的小人格也没问题&lt;/h3&gt;

&lt;p&gt;具有“大人格”抱负的英雄豪杰，难道他们的“小人格”方面真有问题吗？事实绝非如此。
再以管仲为例，在“小人格”标准下看管仲，这个人太菜了，但是幕后真相是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;吾始困时，尝与鲍叔贾，分财利多自与，鲍叔不以我为贪，知我贫也；
吾尝为鲍叔谋事而穷困，鲍叔不以我愚，知时有利不利也；
吾尝三仕三见逐于君，鲍叔不以我为不肖，知我不遭时也；
我尝三战三走，鲍叔不以我为怯，知我有老母也；
公子纠败，召忽死之，吾幽囚受辱，鲍叔不以我为无耻，知我不羞小节而耻功名不显于天下也。
—-生我者父母，知我者鲍子也。 &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这段动人的话，告诉了我们，具有“大人格”胸怀的，他的“小人格”方面，其实没有问题，只是不为匹夫匹妇所知罢了！ &lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;“虽千万人，吾往矣！”&lt;/h3&gt;

&lt;p&gt;一个人走上特立独行的、大无畏的、“虽千万人，吾往矣！”的长路，他的人格，早就在“匹夫匹妇的层面”之上，不是人间大智大仁大勇的，不会这样走；
不是道德至高人品至善的，不会这样走；不是“大人格”涵盖了“小人格”的，不会这样走。 &lt;/p&gt;

&lt;p&gt;绝大部分人千百年来讲道德，却讲错了道德，只讲到独善其身的“乡愿”道德，却没讲到兼善天下的“狂狷”道德。
结果是，中国思想中的“虽千万人，吾往矣！”的理论谁都会说，却很少人敢做，因为一做就倒霉。&lt;/p&gt;

&lt;p&gt;孔夫子攻击“乡愿”，但是千百年下来，人人是“乡愿”，并且以“乡愿”身份，骂“虽千万人，吾往矣！”的少数人“人格有问题”。&lt;/p&gt;

&lt;p&gt;我们不要忘记：在举国滔滔，为阉党拍马祝寿的时候，顾宪成不肯签名，这是何等人格！
在举国滔滔，为国民党歌功颂德的时候，党外人士敢捋虎须，这是何等人格！ &lt;/p&gt;

&lt;p&gt;我们不要忘记：检定人格的第一标准，是看一个人有没有特立独行的、大无畏的、“虽千万人，吾往矣！”的“大人格”，而不是看他有没有匹夫匹妇的“小人格”。
不确认出这种检定标准，人的道德不会有进步，人将永远在滑头的道德水平上做小市民，人永远不会做大丈夫。 &lt;/p&gt;

&lt;p&gt;一九八一年四月六日&lt;/p&gt;

</description>
        <pubDate>Mon, 2014 Jul 21 00:00:00 +0800</pubDate>
        <link>http://jobinson.ga/%E6%B6%85%E7%A3%90/2014/07/21/%E5%A4%A7%E4%BA%BA%E6%A0%BC%E5%92%8C%E5%B0%8F%E4%BA%BA%E6%A0%BC/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E6%B6%85%E7%A3%90/2014/07/21/%E5%A4%A7%E4%BA%BA%E6%A0%BC%E5%92%8C%E5%B0%8F%E4%BA%BA%E6%A0%BC/</guid>
      </item>
    
      <item>
        <title>【公开课】常见编程语言风格</title>
        <description>&lt;p&gt;下面应该越来越少人看了，只要扫一眼有个印象就行，不需要在这里掌握。&lt;/p&gt;

&lt;h2 id=&quot;c&quot;&gt;C&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.buildyourownlisp.com/&quot;&gt;参考：用c来构建一个链码系统&lt;/a&gt; &lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;变量&lt;/h3&gt;

&lt;p&gt;通过 事先定义（statement） 末尾需要一个分号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int count;
int count = 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内建数据类型：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;标识&lt;/th&gt;
      &lt;th&gt;数据类型&lt;/th&gt;
      &lt;th&gt;示例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;void&lt;/td&gt;
      &lt;td&gt;空类型&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;char&lt;/td&gt;
      &lt;td&gt;单字符型/Byte&lt;/td&gt;
      &lt;td&gt;char last_initial = ‘H’;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;int&lt;/td&gt;
      &lt;td&gt;整数&lt;/td&gt;
      &lt;td&gt;int age = 23;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;long&lt;/td&gt;
      &lt;td&gt;长整数&lt;/td&gt;
      &lt;td&gt;long age_of_universe = 13798000000;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;float&lt;/td&gt;
      &lt;td&gt;带小数数字&lt;/td&gt;
      &lt;td&gt;float liters_per_pint = 0.568f;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;double&lt;/td&gt;
      &lt;td&gt;双精度带小数数字&lt;/td&gt;
      &lt;td&gt;double speed_of_swallow = 0.01072896;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-1&quot;&gt;函数定义&lt;/h3&gt;

&lt;p&gt;一对大括号+逗号分隔内部变量+分号，return用于设定输出结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int math-add(int x, int y) {
    int result = x + y;
    return result;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;math-add(10, 18)
&amp;gt; 28
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了方便调用计算结果，把结果存入变量中 一对括号+逗号分隔内部变量+分号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int add4reuse = math-add(10, 18);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题：以上步骤都是在内存中操作，重启机器就没了，如果有需要，则可以进一步写入文件或者数据库中，实现持久性存储。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;结构定义：用于新建 类&lt;/h3&gt;

&lt;p&gt;类 = 多变量绑在一起，变成一个包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct {
    float x;
    float y;
  } point;   /point是新建框架的名字
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建框架的使用。设定实例：实例+点+变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;point p;
p.x = 0.1;
p.y = 10.0;

float length = sqrt(p.x * p.x + p.y * p.y);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;pointer-&quot;&gt;pointer 系统：指针&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;int* x;   /这样的写法对新手来说清晰
int *x;   /这是日常的写法 

/* A pointer to a new empty Qexpr lval */
lval* lval_qexpr(void) {
  lval* v = malloc(sizeof(lval));   /
  v-&amp;gt;type = LVAL_QEXPR;    / 指针属性：类型
  v-&amp;gt;count = 0;    /指针属性：
  v-&amp;gt;cell = NULL;   /指针属性：
  return v;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;char&quot;&gt;字串 &lt;code&gt;char*&lt;/code&gt;&lt;/h3&gt;

&lt;h3 id=&quot;array&quot;&gt;数组 &lt;code&gt;array&lt;/code&gt;&lt;/h3&gt;

&lt;h3 id=&quot;section-3&quot;&gt;条件操控&lt;/h3&gt;

&lt;p&gt;if+括号+若有多个条件，则用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 并列 或 &lt;code&gt;||&lt;/code&gt; 或 分隔&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; if (x &amp;gt; 10 &amp;amp;&amp;amp; x &amp;lt; 100) {
   puts(&quot;x 大于10 且小于100!&quot;);
 } else {
   puts(&quot;x 小于11或者大于99!&quot;);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;循环&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;while&lt;/code&gt; 下面表示从10往1算，递减&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;for &lt;/code&gt;下面表示从0到9算，递增&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  int i = 10;
    while (i &amp;gt; 0) {
      puts(&quot;Loop Iteration&quot;);
      i = i - 1;
    }
    
    for (int i = 0; i &amp;lt; 10; i++) {
      puts(&quot;Loop Iteration&quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;宏&lt;/h3&gt;

&lt;p&gt;用在处理重复性操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define MACROXXX(args, cond, err) if (!(cond)) { xxx(args); return lval_err(err); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 #define 来定义，三个参数分别代表：参照参数，条件，出错信息。整个宏代表：如果条件不成立，则 执行xxx(参照参数)，并输出 出错信息。
注：此处没设定如果条件成立的处理方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 调用 */
MACROXXX(a, (a-&amp;gt;count == 1                 ), &quot;Function &#39;xxx&#39; passed too many arguments!&quot;);
MACROXXX(a, (a-&amp;gt;cell[0]-&amp;gt;type == LVAL_QEXPR), &quot;Function &#39;xxx&#39; passed incorrect type!&quot;);
MACROXXX(a, (a-&amp;gt;cell[0]-&amp;gt;count != 0        ), &quot;Function &#39;xxx&#39; passed {}!&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;c-1&quot;&gt;C的一些机制&lt;/h3&gt;

&lt;p&gt;调-返 （callback）：用于后台加载，后台运算不错，但由于并行计算时代的到来，这个很好的机制变成了最容易出问题的地方。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;设计全面的语言：通链&lt;/h2&gt;

&lt;p&gt;主要的语法特征：前置标识&lt;/p&gt;

&lt;p&gt;机制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;灵活的机制兼顾编写效率和运行效率：
    &lt;ul&gt;
      &lt;li&gt;运作机制：代码可立刻解析运行，从而提升编写效率。也可编译后运行，提升运行效率。&lt;/li&gt;
      &lt;li&gt;类型系统：可以不预先设定数据操作类型，让系统自动辨识，提升代码编写效率。也可以在后期优化时指定数据类型，提升运行效率。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;前瞻性的设计：资源回收机制，总分法，并行计算等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特点：设计非常完备，而且，这样的完备设计已经稳定标准化了多年。&lt;/p&gt;

&lt;p&gt;缺点：普及度不高，而且，因为设计太过完备，难免隐藏不少问题，只是因为应用太少，这些问题暴露的不全。&lt;/p&gt;

&lt;p&gt;对于lisp，只需要学习其设计，而不需要学习其具体的编程&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;难读天书：简符码&lt;/h2&gt;

&lt;p&gt;目的在于提供快速简便的拣选。&lt;/p&gt;

&lt;p&gt;虽然难懂，但因为应用比较多，所以还是需要掌握部分规律。&lt;/p&gt;

&lt;h2 id=&quot;jshtmlcss&quot;&gt;通用常见型：js+html+css特混编队&lt;/h2&gt;

&lt;p&gt;这是目前最流行，也最通用的，虽然效率还不太好，但随着其普及，这方面的改善一直在进行中……&lt;/p&gt;

&lt;p&gt;最主要部分是js，其越来越全能。&lt;/p&gt;

</description>
        <pubDate>Mon, 2014 May 12 22:38:00 +0800</pubDate>
        <link>http://jobinson.ga/%E6%8A%80%E6%9C%AF%E6%99%AE%E5%8F%8A/2014/05/12/%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E6%8A%80%E6%9C%AF%E6%99%AE%E5%8F%8A/2014/05/12/%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC/</guid>
      </item>
    
      <item>
        <title>【公开课】编程语言解剖</title>
        <description>&lt;p&gt;杂七杂八之后，接下来，说说能够组合出程序的编程语言：&lt;/p&gt;

&lt;p&gt;先说说这世界上有啥编程语言。对于正常人而言，计算机编程语言大概就是下面这四种类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;计算机电子信号——&amp;gt;编码为二进制——&amp;gt;助记符（汇编）——&amp;gt;抽象以方便人类操作的语言（比如C）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于前面三种，现在一般人都不需要去直接接触，对于第四种，就是我们日常需要接触掌握的，第四种是非常丰富的，有各种各样，而且，日常编程生产作业中，都是不可避免地需要同时掌握好几个编程语言，才能写出一个可用的程序的，因此，为了快速掌握它们，需要了解它们的一些共有规律。&lt;/p&gt;

&lt;p&gt;另外，对于有些特殊要求的，比如前面说到的瘫痪的人，可能其计算机编程语言就演变成如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;计算机电子信号——&amp;gt;编码为二进制——&amp;gt;助记符（汇编）——&amp;gt;摩斯码或者可能的盲文编程语言（目前还不存在这种语言）
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;为什么会有这么多的语言呢？&lt;/h3&gt;

&lt;p&gt;从打孔机时代一路走来&lt;/p&gt;

&lt;p&gt;为了表达 &lt;code&gt;1 + 2 + ... + 10 = 55&lt;/code&gt; 并打印出结果，需要：&lt;/p&gt;

&lt;p&gt;其特点：操作 操作对象 内存位置。再复杂的逻辑，都可以简化为如此形式。
初看运算范围是有限的：不超过8位二进制所能表达的范围，当然，有办法表达所有数字，就是运用科学计数法。
这是没有资源回收的版本，会导致有三个内存位置一直被占用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;00110001 00000000 00000000
00110001 00000001 00000001
00110011 00000001 00000010
01010001 00001011 00000010
00100010 00000010 00001000
01000011 00000001 00000000
01000001 00000001 00000001
00010000 00000010 00000000
01100010 00000000 00000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每句解释：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;[结果]把数字0 存放到 内存位置 0 中&lt;/li&gt;
  &lt;li&gt;[运算材料]把数字1 存放到 内存位置 1 中&lt;/li&gt;
  &lt;li&gt;[运算]把 内存位置1的&lt;strong&gt;值&lt;/strong&gt; 存放到内存位置 2 中&lt;/li&gt;
  &lt;li&gt;[设定范围] 内存位置 2 的值 减去 11&lt;/li&gt;
  &lt;li&gt;[设定范围] 若 内存位置2的值为0 ，则跳转到第九步&lt;/li&gt;
  &lt;li&gt;[累计结果]把内存位置1的值 加入到内存位置 0 中&lt;/li&gt;
  &lt;li&gt;[递增] 把内存位置1的值 加1&lt;/li&gt;
  &lt;li&gt;[跳转]继续第三步&lt;/li&gt;
  &lt;li&gt;[输出]把 位于内存位置 0 的值 输出。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;进一步发展编程语言，利用借记符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Set “total” to 0
 Set “count” to 1
[loop]
 Set “compare” to “count”
 Subtract 11 from “compare”
 If “compare” is zero, continue at [end]
 Add “count” to “total”
 Add 1 to “count”
 Continue at [loop]
[end]
 Output “total”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中文解释：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;设 “总值” 初始值为 0&lt;/li&gt;
  &lt;li&gt;设 “累加值”初始值为 1&lt;/li&gt;
  &lt;li&gt;[循环执行]&lt;/li&gt;
  &lt;li&gt;设 “范围” 为 “累加值”&lt;/li&gt;
  &lt;li&gt;“范围” - 11&lt;/li&gt;
  &lt;li&gt;如果 “范围” = 0 转到 [结果]&lt;/li&gt;
  &lt;li&gt;总值 = 累加值&lt;/li&gt;
  &lt;li&gt;累加值 = 累加值 + 1&lt;/li&gt;
  &lt;li&gt;转到 [循环执行]&lt;/li&gt;
  &lt;li&gt;[结果]&lt;/li&gt;
  &lt;li&gt;输出 “总值”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现代编程语言 js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var total = 0, count = 1;
while (count &amp;lt;= 10) {
  total += count;
  count += 1;
}
console.log(total);
// → 55
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，理论上还可以进一步简化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(sum(range(1, 10)));
// → 55
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：8位二进制可以表达多少？
示例：13，用二进制表示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  0   0   0   0   1   1   0   1
128  64  32  16   8   4   2   1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是： &lt;code&gt;00001101&lt;/code&gt; 或者 &lt;code&gt;8+4+1=13&lt;/code&gt; 。依此类推，8位数可以一共表达256，ascii的基础码共128（编码还不够简约，其实26个大写字母可以只用加一位即可判断，不需要硬编码进去），包含扩展码后共256个。&lt;/p&gt;

&lt;aside&gt;个人观点：其实，汉字如果用笔画+位置来编码的话，也不需要那么多：假设10个基本笔画，42个位置信息，则可以编码 10^42=10e+42&lt;/aside&gt;

&lt;h3 id=&quot;section-1&quot;&gt;语言发展的动力&lt;/h3&gt;

&lt;p&gt;编程语言是不完美的，现实情况的变化，编程语言也是需要不断发展的。&lt;/p&gt;

&lt;p&gt;编程语言进化的动力，就是不满！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Algol: 汇编太底层了。&lt;/li&gt;
    &lt;li&gt;Pascal: Algol语言缺少足够的数据类型。&lt;/li&gt;
    &lt;li&gt;Modula: Pascal语言对于系统应用编程来说太弱了。&lt;/li&gt;
    &lt;li&gt;Simula: Algol语言在仿真模拟方面不够好。&lt;/li&gt;
    &lt;li&gt;Smalltalk: Simula语言里并不是所有的东西都是对象。&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;Fortran: 汇编太底层了。&lt;/li&gt;
    &lt;li&gt;Cobol: Fortran语言不好用。&lt;/li&gt;
    &lt;li&gt;PL/1: Fortran语言缺少足够的数据类型。&lt;/li&gt;
    &lt;li&gt;Ada: 所有现存的编程语言都有缺失。&lt;/li&gt;
    &lt;li&gt;Basic: Fortran语言不好用。&lt;/li&gt;
    &lt;li&gt;APL: Fortran语言在数组操作上不好用。&lt;/li&gt;
    &lt;li&gt;J: APL语言需要自己的字符集。&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;C: 汇编太底层了。&lt;/li&gt;
    &lt;li&gt;C++: C语言太底层了。&lt;/li&gt;
    &lt;li&gt;Java: C++太笨重。微软在压迫我们。&lt;/li&gt;
    &lt;li&gt;C#: Java是Sun公司控制的。&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;Lisp: 用图灵机方式描述计算机计算太别扭。&lt;/li&gt;
    &lt;li&gt;Scheme: MacLisp语言太笨拙。&lt;/li&gt;
    &lt;li&gt;T: Scheme语言没有程序库。&lt;/li&gt;
    &lt;li&gt;Common Lisp: Lisp方言太多了。&lt;/li&gt;
    &lt;li&gt;Dylan: Scheme语言没有程序库，Lisp语法太疯狂。&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;Perl: Shell脚本/awk/sed都不像编程语言。&lt;/li&gt;
    &lt;li&gt;Python: Perl语言太让人受不了。&lt;/li&gt;
    &lt;li&gt;Ruby: Perl语言太笨拙，Lisp语法太疯狂。&lt;/li&gt;
    &lt;li&gt;Prolog: 编程不够逻辑。&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;js： java不适合新手&lt;/li&gt;
    &lt;li&gt;易语言:你们都不支持中文编程 &lt;/li&gt;
    &lt;li&gt;爱编：你们都不国际化&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;目前处于大整合阶段：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;界面使用统一跨平台语言：html+css+js&lt;/li&gt;
  &lt;li&gt;效率：开发效率，运行效率需要平衡&lt;/li&gt;
  &lt;li&gt;国际化： 更易用、高效的编程——提升开发效率，降低学习难度&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;语法流派&lt;/h3&gt;

&lt;p&gt;先说说语法，人类社会中存在大概三种下命令方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;领导说：“甲乙丙丁！”甲乙丙丁：“在！”领导：“你们去ooxx！”甲乙丙丁：“是！”&lt;/li&gt;
  &lt;li&gt;另一种是：领导说：我们要去ooxx，嗯，甲乙丙丁，你们去做这件事吧！&lt;/li&gt;
  &lt;li&gt;简化命令法：甲乙丙丁 去xxx&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;第一种是一般常见的编程语言，比如c，js。&lt;/li&gt;
  &lt;li&gt;第二种是链码等各种前置标识表达式或者成对标识语言会采用的方式。&lt;/li&gt;
  &lt;li&gt;第三种一般是用在脚本语言，好处是快速简洁，但程序一长，就很难懂。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种和第三种都是直抒式，第二种是抽象式。为什么会有这么些方式呢？&lt;/p&gt;

&lt;p&gt;第一种和第三种是： &lt;code&gt;2+3+0=5&lt;/code&gt;  （需要写2个+号）&lt;/p&gt;

&lt;p&gt;第二种是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    2
    3
+   0
-------
    5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好处：节省笔墨，语义化易懂。（只需要写一个+号，可见设计者明显是个有办法的懒人）&lt;/p&gt;

&lt;p&gt;前置标识表达式有很多种：比如链码，markdown，比如json，其实C和JS也算部分的前置表达，但其表达式内部都是直抒式的。&lt;/p&gt;

&lt;p&gt;网标码的成对语义化表达方式，太过浪费笔墨。&lt;/p&gt;

&lt;p&gt;另外几种特殊的编码，比如摩斯码、简符码等简化命令式，则很难懂。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;程序的共有特征&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;编程语言的构成要素&lt;/h3&gt;

&lt;p&gt;一套编程语言，无非是：&lt;strong&gt;表达的类型+操作（读、写、查），穷尽各种组合就是了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般而言，编程语言之间的不同，在于抽象方式各异：各个语言为了达成自己的主要目的，在着眼点上会极尽所能的抽象方式，提供该方面尽可能大的可操控能力，该方面的稳定性，该方面的可测试性。&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;         类型 |纵坐标：操作对象
              |
         与非 |
         数字 |
         字符 |
         内名 |
    横坐标____|______________________________________
    操作      |    读     查    写
       字符串 |
       数据流 |
           树 |
           表 |
         函数 |
         向量 |
         链串 |
         拓扑 |
         闭合 |
       连续统 |
     提示信息 |
     文件路径 |
       程序包 |
              |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;进一步细分：&lt;/p&gt;

&lt;p&gt;【类型】：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数字（整数、单数、复数、浮点数……进制，关联操作加减乘除可以看成是合并、删除、拆分等操作）&lt;/li&gt;
  &lt;li&gt;名-属性类（集、数组、数列、链串、清单、拓扑、散列表、列联表、对应表、字典、n维表、向量、序列……）&lt;/li&gt;
  &lt;li&gt;程序包级别（类、名位、包、系统……）&lt;/li&gt;
  &lt;li&gt;提示信息（提示、示警、出错仍继续、出错中止）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;【操作】：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;读（读法，列出所有，统计）&lt;/li&gt;
  &lt;li&gt;查[判断，查有没有，要哪个，在哪]&lt;/li&gt;
  &lt;li&gt;写[改变（类型/值/位置），新造，删除，合并，拆分]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;【怎么操作】：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;默认：按先后顺序操作&lt;/li&gt;
  &lt;li&gt;流程控制：条件控制&lt;/li&gt;
  &lt;li&gt;重复操作：宏
    &lt;ul&gt;
      &lt;li&gt;自动脚本&lt;/li&gt;
      &lt;li&gt;统筹法&lt;/li&gt;
      &lt;li&gt;框架&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;新设计语言可以参考神编和sibilant的构造经验：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;设定存在的类型，&lt;/li&gt;
  &lt;li&gt;批量判断输入输出类型是否正确，逐个判断还是批量判断？，&lt;/li&gt;
  &lt;li&gt;具体设定各个函数的功能，但不判断类型，只读入读出？。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-5&quot;&gt;编程语言常有的机制&lt;/h3&gt;

&lt;p&gt;命名：对每个操作和操作对象都命名，以方便调用。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;程序设计思路：抽象，化整为零&lt;/h3&gt;

&lt;p&gt;抽象化，自动化&lt;/p&gt;

&lt;p&gt;化整为零，简化问题解决方式&lt;/p&gt;

</description>
        <pubDate>Mon, 2014 May 05 00:00:00 +0800</pubDate>
        <link>http://jobinson.ga/%E6%8A%80%E6%9C%AF%E6%99%AE%E5%8F%8A/2014/05/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%A7%A3%E5%89%96/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E6%8A%80%E6%9C%AF%E6%99%AE%E5%8F%8A/2014/05/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%A7%A3%E5%89%96/</guid>
      </item>
    
      <item>
        <title>个人知识管理经验汇总</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;个人知识管理&lt;/h2&gt;

&lt;p&gt;目的：主要用于收集学习的资料，做笔记，想一些零碎的想法。&lt;/p&gt;

&lt;p&gt;两种主要用途：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;知识笔记：不断累加的，有些因为各种原因需要保密——还可能需要别人也参与修改，但因为有了git这种工具，使得维基不再是唯一的方式。换句话就是方便的持续集成！&lt;/li&gt;
  &lt;li&gt;个人日志：不需要修改的，有些隐私，需要保密权限的设定&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了最大化效率，需要做到：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;掌握一种富格式文本：因为文本最通用&lt;/li&gt;
  &lt;li&gt;理想学习生态链：版本管理——所见即所得编辑——发布——持续修订&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;利用版本管理来管理协作社区！&lt;/li&gt;
  &lt;li&gt;利用简化的格式，来专注内容&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;选用工具&lt;/h3&gt;

&lt;p&gt;下面列出我自己用过的各种个人知识工具总结：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;工具&lt;/th&gt;
      &lt;th&gt;优点&lt;/th&gt;
      &lt;th&gt;缺点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;word类&lt;/td&gt;
      &lt;td&gt;格式完美，批注方便&lt;/td&gt;
      &lt;td&gt;编辑软件不通用，编辑软件有点大，发布不方便&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;博客类&lt;/td&gt;
      &lt;td&gt;用过博客中国，搜狐，网易的&lt;/td&gt;
      &lt;td&gt;过分依赖特定服务器，定制性不够&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wordpress&lt;/td&gt;
      &lt;td&gt;定制能力好，网上到处可见其身影&lt;/td&gt;
      &lt;td&gt;自己管理服务器麻烦，之前自己建过类似的，后来懒得麻烦了就重回网易博客&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wiki类&lt;/td&gt;
      &lt;td&gt;可定制，内部索引完美&lt;/td&gt;
      &lt;td&gt;也是需要依赖服务器，不用服务器的tiddlywiki是打包到一个文件中，及其变态&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;笔记类网站&lt;/td&gt;
      &lt;td&gt;简单方便, 非常适合于做笔记&lt;/td&gt;
      &lt;td&gt;用了360doc好几年，还一直用网易的笔记，印象笔记用过一阵子放弃了，这类的缺点是依赖服务器，自主性不够，整理花费时间长（主要是操作需要等等服务器反馈，时间冗长）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;basket类&lt;/td&gt;
      &lt;td&gt;灵活，添加点子很方便，界面漂亮快速&lt;/td&gt;
      &lt;td&gt;导出太丑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;org-mode&lt;/td&gt;
      &lt;td&gt;用起来很爽，功能丰富&lt;/td&gt;
      &lt;td&gt;调教所需花费的时间太多&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;github+jekyll&lt;/td&gt;
      &lt;td&gt;方便版本管理，流畅的操作流程&lt;/td&gt;
      &lt;td&gt;jekyll本身转码器不甚满意，不过已经可以算很满意了。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;静态空间+版本管理+生成工具&lt;/td&gt;
      &lt;td&gt;定制能力逆天，而且可以累积的，有空就改改，最接近完美的&lt;/td&gt;
      &lt;td&gt;可以用各种生成工具，从pandoc，orgmode到makefile任意&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中，用得觉得爽的是：360doc，basket，orgmode，markdown+jekyll。
最后三种，可以做到本地笔记和发布的笔记同步，从而不用同时维护两种，彻底打通整个链条。
比如本文，本地和远程原来就是两个版本，有了后面工具后，就合并为一个了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;知识笔记的需求&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;容易转为其他格式的：也就是语法要通用性好，或者说各种格式转换方便，尤其是要有转出为html能力：有pandoc这个转换利器，html-org，html-markdown，markdown-html的转换不是啥问题。但org只能在orgmode里转html。&lt;/li&gt;
  &lt;li&gt;编辑方便的：
    &lt;ul&gt;
      &lt;li&gt;如果没有所见即所得编辑器，则语法要简练。&lt;/li&gt;
      &lt;li&gt;编辑器要好用。——最好有所见即所得的编辑器。但所见即所得编辑器只可以编辑看得见的，看不见的编辑不了，掌控不到全局。&lt;/li&gt;
      &lt;li&gt;html配合zencoding后，写起来爽的一塌糊涂。相比而言，markdown，orgmode都还要略为逊色。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;普通阅读干扰少的：html渲染后虽然不错，但如果不渲染，其符号太多，阅读干扰大，尤其是一些手持设备还普遍对所见即所得编辑器有巨大的问题的时候，在这些设备上编辑会很麻烦。&lt;/li&gt;
  &lt;li&gt;格式要求：
    &lt;ul&gt;
      &lt;li&gt;有方便的大纲显示：学习和创作中，知识的系统性很重要。word有大纲视图，易码肆配合speedbar可以搞定，内部也可以用outline来搞大纲视图。&lt;/li&gt;
      &lt;li&gt;内容与样式分离, 写作专注于内容，长啥样后期控制，或者阅读者控制。&lt;/li&gt;
      &lt;li&gt;标题&lt;/li&gt;
      &lt;li&gt;段落&lt;/li&gt;
      &lt;li&gt;具备2种以上复加强调功能, 包括粗体, 颜色。——html可搞定，orgmode可以通过特殊设置，markdown可通过嵌入html代码解决。&lt;/li&gt;
      &lt;li&gt;表格&lt;/li&gt;
      &lt;li&gt;列表: 有序 和 无序&lt;/li&gt;
      &lt;li&gt;代码相关:
        &lt;ul&gt;
          &lt;li&gt;原样输入：orgmode在插入自身的特有代码时需要注意一下。markdown由于利用缩进，可以做到表述自身代码很容易。&lt;/li&gt;
          &lt;li&gt;原样输出&lt;/li&gt;
          &lt;li&gt;代码高亮&lt;/li&gt;
          &lt;li&gt;最好有 元文档能力： 代码可以运行获得结果，也可以以源码形式保留。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;发布：
    &lt;ul&gt;
      &lt;li&gt;可以转化为静态html用于网站发布&lt;/li&gt;
      &lt;li&gt;能自动生成目录功能。&lt;/li&gt;
      &lt;li&gt;页眉页脚与配色方案等可以独立于每篇文章作成模板。&lt;/li&gt;
      &lt;li&gt;本地与在线都能使用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;内容管理:
    &lt;ul&gt;
      &lt;li&gt;使用版本管理: 不会担心什么误操作把辛苦多年的积累给干掉.&lt;/li&gt;
      &lt;li&gt;版本管理工具最好是分布式的, 不依赖于服务器, 这样费用就低, 离线使用也方便。&lt;/li&gt;
      &lt;li&gt;可以通过版本管理工具进行多人协作。&lt;/li&gt;
      &lt;li&gt;可以通过查看代码改动来做文档批注工具。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 2014 Apr 29 22:53:21 +0800</pubDate>
        <link>http://jobinson.ga/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/2014/04/29/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E7%BB%8F%E9%AA%8C/</link>
        <guid isPermaLink="true">http://jobinson.ga/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/2014/04/29/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E7%BB%8F%E9%AA%8C/</guid>
      </item>
    
  </channel>
</rss>
